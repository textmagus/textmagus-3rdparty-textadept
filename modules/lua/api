new_buffer _G.new_buffer()\nCreates a new buffer. Activates the 'buffer_new' signal.\n@return the new buffer.\n
quit _G.quit()\nQuits Textadept.\n
reset _G.reset()\nResets the Lua state by reloading all init scripts. Language-specific modules\nfor opened files are NOT reloaded. Re-opening the files that use them will\nreload those modules. This function is useful for modifying init scripts\n(such as keys.lua) on the fly without having to restart Textadept. A global\nRESETTING variable is set to true when re-initing the Lua State. Any scripts\nthat need to differentiate between startup and reset can utilize this variable.\n
timeout _G.timeout(interval, f, ...)\nCalls a given function after an interval of time. To repeatedly call the\nfunction, return true inside the function. A nil or false return value\nstops repetition.\n@param The interval in seconds to call the function after.\n@param The function to call.\n@param Additional arguments to pass to f.\n
user_dofile _G.user_dofile(filename)\nCalls 'dofile' on the given filename in the user's Textadept directory. This\nis typically used for loading user files like key commands or snippets. Errors\nare printed to the Textadept message buffer.\n@param The name of the file (not path).\n@return true if successful; false otherwise.\n
assert _G.assert(v [, message])\nIssues an error when the value of its argument `v` is false (i.e., nil or\nfalse); otherwise, returns all its arguments. `message` is an error message;\nwhen absent, it defaults to "assertion failed!"\n
collectgarbage _G.collectgarbage(opt [, arg])\nThis function is a generic interface to the garbage collector. It performs\ndifferent functions according to its first argument, `opt`: "stop": stops the\ngarbage collector. "restart": restarts the garbage collector. "collect":\nperforms a full garbage-collection cycle. "count": returns the total\nmemory in use by Lua (in Kbytes). "step": performs a garbage-collection\nstep. The step "size" is controlled by `arg` (larger values mean more\nsteps) in a non-specified way. If you want to control the step size you\nmust experimentally tune the value of `arg`. Returns true if the step\nfinished a collection cycle. "setpause": sets `arg` as the new value for\nthe *pause* of the collector (see §2.10). Returns the previous value for\n*pause*. "setstepmul": sets `arg` as the new value for the *step multiplier*\nof the collector (see §2.10). Returns the previous value for *step*.\n
dofile _G.dofile(filename)\nOpens the named file and executes its contents as a Lua chunk. When called\nwithout arguments, `dofile` executes the contents of the standard input\n(`stdin`). Returns all values returned by the chunk. In case of errors,\n`dofile` propagates the error to its caller (that is, `dofile` does not run\nin protected mode).\n
error _G.error(message [, level])\nTerminates the last protected function called and returns `message` as the\nerror message. Function `error` never returns. Usually, `error` adds some\ninformation about the error position at the beginning of the message. The\n`level` argument specifies how to get the error position. With level 1 (the\ndefault), the error position is where the `error` function was called. Level\n2 points the error to where the function that called `error` was called; and\nso on. Passing a level 0 avoids the addition of error position information\nto the message.\n
close file:close()\nCloses `file`. Note that files are automatically closed when their handles are\ngarbage collected, but that takes an unpredictable amount of time to happen.\n
flush file:flush()\nSaves any written data to `file`.\n
lines file:lines()\nReturns an iterator function that, each time it is called, returns a new\nline from the file. Therefore, the construction for line in file:lines()\ndo *body* end will iterate over all lines of the file. (Unlike `io.lines`,\nthis function does not close the file when the loop ends.)\n
read file:read(···)\nReads the file `file`, according to the given formats, which specify what\nto read. For each format, the function returns a string (or a number)\nwith the characters read, or nil if it cannot read data with the specified\nformat. When called without formats, it uses a default format that reads the\nentire next line (see below). The available formats are "*n": reads a number;\nthis is the only format that returns a number instead of a string. "*a":\nreads the whole file, starting at the current position. On end of file,\nit returns the empty string. "*l": reads the next line (skipping the end of\nline), returning nil on end of file. This is the default format. *number*:\nreads a string with up to this number of characters, returning nil on end\nof file. If number is zero, it reads nothing and returns an empty string,\nor nil on end of file.\n
seek file:seek([whence] [, offset])\nSets and gets the file position, measured from the beginning of the file,\nto the position given by `offset` plus a base specified by the string\n`whence`, as follows: "set": base is position 0 (beginning of the file);\n"cur": base is current position; "end": base is end of file; In case of\nsuccess, function `seek` returns the final file position, measured in bytes\nfrom the beginning of the file. If this function fails, it returns nil, plus\na string describing the error. The default value for `whence` is `"cur"`, and\nfor `offset` is 0. Therefore, the call `file:seek()` returns the current file\nposition, without changing it; the call `file:seek("set")` sets the position\nto the beginning of the file (and returns 0); and the call `file:seek("end")`\nsets the position to the end of the file, and returns its size.\n
setvbuf file:setvbuf(mode [, size])\nSets the buffering mode for an output file. There are three available\nmodes: "no": no buffering; the result of any output operation appears\nimmediately. "full": full buffering; output operation is performed only\nwhen the buffer is full (or when you explicitly `flush` the file (see\n`io.flush`)). "line": line buffering; output is buffered until a newline is\noutput or there is any input from some special files (such as a terminal\ndevice). For the last two cases, `size` specifies the size of the buffer,\nin bytes. The default is an appropriate size.\n
write file:write(···)\nWrites the value of each of its arguments to the `file`. The arguments must be\nstrings or numbers. To write other values, use `tostring` or `string.format`\nbefore `write`.\n
getfenv _G.getfenv([f])\nReturns the current environment in use by the function. `f` can be a Lua\nfunction or a number that specifies the function at that stack level:\nLevel 1 is the function calling `getfenv`. If the given function is not a\nLua function, or if `f` is 0, `getfenv` returns the global environment. The\ndefault for `f` is 1.\n
getmetatable _G.getmetatable(object)\nIf `object` does not have a metatable, returns nil. Otherwise, if the object's\nmetatable has a `"__metatable"` field, returns the associated value. Otherwise,\nreturns the metatable of the given object.\n
ipairs _G.ipairs(t)\nReturns three values: an iterator function, the table `t`, and 0, so that\nthe construction for i,v in ipairs(t) do *body* end will iterate over the\npairs (`1,t[1]`), (`2,t[2]`), ···, up to the first integer key absent\nfrom the table.\n
load _G.load(func [, chunkname])\nLoads a chunk using function `func` to get its pieces. Each call to `func`\nmust return a string that concatenates with previous results. A return of\nan empty string, nil, or no value signals the end of the chunk. If there\nare no errors, returns the compiled chunk as a function; otherwise, returns\nnil plus the error message. The environment of the returned function is the\nglobal environment. `chunkname` is used as the chunk name for error messages\nand debug information. When absent, it defaults to "`=(load)`".\n
loadfile _G.loadfile([filename])\nSimilar to `load`, but gets the chunk from file `filename` or from the\nstandard input, if no file name is given.\n
loadstring _G.loadstring(string [, chunkname])\nSimilar to `load`, but gets the chunk from the given string. To load and\nrun a given string, use the idiom assert(loadstring(s))() When absent,\n`chunkname` defaults to the given string.\n
module _G.module(name [, ···])\nCreates a module. If there is a table in `package.loaded[name]`, this table is\nthe module. Otherwise, if there is a global table `t` with the given name, this\ntable is the module. Otherwise creates a new table `t` and sets it as the value\nof the global `name` and the value of `package.loaded[name]`. This function\nalso initializes `t._NAME` with the given name, `t._M` with the module (`t`\nitself), and `t._PACKAGE` with the package name (the full module name minus\nlast component; see below). Finally, `module` sets `t` as the new environment\nof the current function and the new value of `package.loaded[name]`, so\nthat `require` returns `t`. If `name` is a compound name (that is, one\nwith components separated by dots), `module` creates (or reuses, if they\nalready exist) tables for each component. For instance, if `name` is `a.b.c`,\nthen `module` stores the module table in field `c` of field `b` of global\n`a`. This function can receive optional *options* after the module name,\nwhere each option is a function to be applied over the module.\n
next _G.next(table [, index])\nAllows a program to traverse all fields of a table. Its first argument is\na table and its second argument is an index in this table. `next` returns\nthe next index of the table and its associated value. When called with nil\nas its second argument, `next` returns an initial index and its associated\nvalue. When called with the last index, or with nil in an empty table,\n`next` returns nil. If the second argument is absent, then it is interpreted\nas nil. In particular, you can use `next(t)` to check whether a table is\nempty. The order in which the indices are enumerated is not specified, *even\nfor numeric indices*. (To traverse a table in numeric order, use a numerical\nfor or the `ipairs` function.) The behavior of `next` is *undefined* if,\nduring the traversal, you assign any value to a non-existent field in the\ntable. You may however modify existing fields. In particular, you may clear\nexisting fields.\n
pairs _G.pairs(t)\nReturns three values: the `next` function, the table `t`, and nil, so that\nthe construction for k,v in pairs(t) do *body* end will iterate over all\nkey–value pairs of table `t`. See function `next` for the caveats of\nmodifying the table during its traversal.\n
pcall _G.pcall(f, arg1, ···)\nCalls function `f` with the given arguments in *protected mode*. This means\nthat any error inside `f` is not propagated; instead, `pcall` catches the\nerror and returns a status code. Its first result is the status code (a\nboolean), which is true if the call succeeds without errors. In such case,\n`pcall` also returns all results from the call, after this first result. In\ncase of any error, `pcall` returns false plus the error message.\n
print _G.print(···)\nReceives any number of arguments, and prints their values to `stdout`,\nusing the `tostring` function to convert them to strings. `print` is not\nintended for formatted output, but only as a quick way to show a value,\ntypically for debugging. For formatted output, use `string.format`.\n
rawequal _G.rawequal(v1, v2)\nChecks whether `v1` is equal to `v2`, without invoking any metamethod. Returns\na boolean.\n
rawget _G.rawget(table, index)\nGets the real value of `table[index]`, without invoking any metamethod. `table`\nmust be a table; `index` may be any value.\n
rawset _G.rawset(table, index, value)\nSets the real value of `table[index]` to `value`, without invoking any\nmetamethod. `table` must be a table, `index` any value different from nil,\nand `value` any Lua value. This function returns `table`.\n
require _G.require(modname)\nLoads the given module. The function starts by looking into the\n`package.loaded` table to determine whether `modname` is already\nloaded. If it is, then `require` returns the value stored at\n`package.loaded[modname]`. Otherwise, it tries to find a *loader* for the\nmodule. To find a loader, `require` is guided by the `package.loaders`\narray. By changing this array, we can change how `require` looks for a\nmodule. The following explanation is based on the default configuration for\n`package.loaders`. First `require` queries `package.preload[modname]`. If it\nhas a value, this value (which should be a function) is the loader. Otherwise\n`require` searches for a Lua loader using the path stored in `package.path`. If\nthat also fails, it searches for a C loader using the path stored in\n`package.cpath`. If that also fails, it tries an *all-in-one* loader (see\n`package.loaders`). Once a loader is found, `require` calls the loader with\na single argument, `modname`. If the loader returns any value, `require`\nassigns the returned value to `package.loaded[modname]`. If the loader returns\nno value and has not assigned any value to `package.loaded[modname]`, then\n`require` assigns true to this entry. In any case, `require` returns the\nfinal value of `package.loaded[modname]`. If there is any error loading or\nrunning the module, or if it cannot find any loader for the module, then\n`require` signals an error.\n
select _G.select(index, ···)\nIf `index` is a number, returns all arguments after argument number\n`index`. Otherwise, `index` must be the string `"#"`, and `select` returns\nthe total number of extra arguments it received.\n
setfenv _G.setfenv(f, table)\nSets the environment to be used by the given function. `f` can be a Lua\nfunction or a number that specifies the function at that stack level: Level 1\nis the function calling `setfenv`. `setfenv` returns the given function. As a\nspecial case, when `f` is 0 `setfenv` changes the environment of the running\nthread. In this case, `setfenv` returns no values.\n
setmetatable _G.setmetatable(table, metatable)\nSets the metatable for the given table. (You cannot change the metatable\nof other types from Lua, only from C.) If `metatable` is nil, removes the\nmetatable of the given table. If the original metatable has a `"__metatable"`\nfield, raises an error. This function returns `table`.\n
tonumber _G.tonumber(e [, base])\nTries to convert its argument to a number. If the argument is already a number\nor a string convertible to a number, then `tonumber` returns this number;\notherwise, it returns nil. An optional argument specifies the base to interpret\nthe numeral. The base may be any integer between 2 and 36, inclusive. In bases\nabove 10, the letter '`A`' (in either upper or lower case) represents 10,\n'`B`' represents 11, and so forth, with '`Z`' representing 35. In base 10\n(the default), the number can have a decimal part, as well as an optional\nexponent part (see §2.1). In other bases, only unsigned integers are accepted.\n
tostring _G.tostring(e)\nReceives an argument of any type and converts it to a string in a\nreasonable format. For complete control of how numbers are converted, use\n`string.format`. If the metatable of `e` has a `"__tostring"` field, then\n`tostring` calls the corresponding value with `e` as argument, and uses the\nresult of the call as its result.\n
type _G.type(v)\nReturns the type of its only argument, coded as a string. The possible results\nof this function are " `nil`" (a string, not the value nil), "`number`",\n"`string`", "`boolean`", "`table`", "`function`", "`thread`", and "`userdata`".\n
unpack _G.unpack(list [, i [, j]])\nReturns the elements from the given table. This function is equivalent to\nreturn list[i], list[i+1], ···, list[j] except that the above code can\nbe written only for a fixed number of elements. By default, `i` is 1 and\n`j` is the length of the list, as defined by the length operator (see §2.5.5).\n
xpcall _G.xpcall(f, err)\nThis function is similar to `pcall`, except that you can set a new error\nhandler. `xpcall` calls function `f` in protected mode, using `err` as the\nerror handler. Any error inside `f` is not propagated; instead, `xpcall`\ncatches the error, calls the `err` function with the original error object,\nand returns a status code. Its first result is the status code (a boolean),\nwhich is true if the call succeeds without errors. In this case, `xpcall`\nalso returns all results from the call, after this first result. In case of\nany error, `xpcall` returns false plus the result from `err`.\n
_HOME _G._HOME\nPath to the directory containing Textadept.\n
_LEXERPATH _G._LEXERPATH\nPaths to lexers, formatted like `package.path`.\n
_RELEASE _G._RELEASE\nThe Textadept release version.\n
_THEME _G._THEME\nThe theme file to use.\n
_USERHOME _G._USERHOME\nPath to the user's `~/.textadept/`.\n
_CHARSET _G._CHARSET\nThe character set encoding of the filesystem. This is used in File I/O.\n
RESETTING _G.RESETTING\nIf `reset()` has been called, this flag is `true` while the Lua state is\nbeing re-initialized.\n
WIN32 _G.WIN32\nIf Textadept is running on Windows, this flag is `true`.\n
OSX _G.OSX\nIf Textadept is running on Mac OSX, this flag is `true`.\n
_G _G._G\nA global variable (not a function) that holds the global environment\n(that is, `_G._G = _G`). Lua itself does not use this variable; changing\nits value does not affect any environment, nor vice-versa. (Use `setfenv`\nto change environments.)\n
_VERSION _G._VERSION\nA global variable (not a function) that holds a string containing the current\ninterpreter version. The current contents of this variable is "`Lua 5.1`".\n
set_buffer_properties _m.cpp.set_buffer_properties()\nSets default buffer properties for C/C++ files.\n
sense _m.cpp.sense\nThe C/C++ Adeptsense.\n
set_buffer_properties _m.css.set_buffer_properties()\nSets default buffer properties for CSS files.\n
sense _m.css.sense\nThe CSS Adeptsense.\n
set_buffer_properties _m.hypertext.set_buffer_properties()\nSets default buffer properties for HTML files.\n
sense _m.hypertext.sense\nThe HTML Adeptsense.\n
set_buffer_properties _m.java.set_buffer_properties()\nSets default buffer properties for Java files.\n
sense _m.java.sense\nThe Java Adeptsense.\n
goto_required _m.lua.goto_required()\nDetermines the Lua file being 'require'd, searches through package.path for\nthat file, and opens it in Textadept.\n
set_buffer_properties _m.lua.set_buffer_properties()\nSets default buffer properties for Lua files.\n
try_to_autocomplete_end _m.lua.try_to_autocomplete_end()\nTries to autocomplete Lua's 'end' keyword for control structures like 'if',\n'while', 'for', etc.\n@see control_structure_patterns\n
sense _m.lua.sense\nThe Lua Adeptsense.\n
load_project _m.rails.load_project(utf8_dir)\nSets _G.keys.al.o to snapopen a Rails project. If not directory is provided,\nthe user is prompted for one.\n@param The UTF-8 Rails project directory.\n
sense _m.rails.sense\nThe Rails Adeptsense.\n
singular _m.rails.singular\nA map of plural controller names to their singulars. Add key-value pairs to\nthis if singularize() is incorrectly converting your plural controller name\nto its singular model name.\n
sense _m.rhtml.sense\nThe RHTML Adeptsense.\n
goto_required _m.ruby.goto_required()\nDetermine the Ruby file being 'require'd, and search through the RUBYPATH\nfor that file and open it in Textadept.\n
set_buffer_properties _m.ruby.set_buffer_properties()\nSets default buffer properties for Ruby files.\n
toggle_block _m.ruby.toggle_block()\nToggles between { ... } and do ... end Ruby blocks. If the caret is inside\na { ... } single-line block, that block is converted to a multiple-line do\n.. end block. If the caret is on a line that contains single-line do ... end\nblock, that block is converted to a single-line { ... } block. If the caret\nis inside a multiple-line do ... end block, that block is converted to a\nsingle-line { ... } block with all newlines replaced by a space. Indentation\nis important. The 'do' and 'end' keywords must be on lines with the same\nlevel of indentation to toggle correctly\n
try_to_autocomplete_end _m.ruby.try_to_autocomplete_end()\nTries to autocomplete Ruby's 'end' keyword for control structures like 'if',\n'while', 'for', etc.\n@see control_structure_patterns\n
sense _m.ruby.sense\nThe Ruby Adeptsense.\n
add_trigger _m.textadept.adeptsense.add_trigger(sense, c, only_fields, only_functions)\nSets the trigger for autocompletion.\n@param The adeptsense returned by adeptsense.new().\n@param The character(s) that triggers the autocompletion. You can have up\nto two characters.\n@param If true, this trigger only completes fields. Defaults to false.\n@param If true, this trigger only completes functions. Defaults to false.\n@usage sense:add_trigger('.')\n@usage sense:add_trigger(':', false, true) -- only functions\n@usage sense:add_trigger('->')\n
clear _m.textadept.adeptsense.clear(sense)\nClears an adeptsense. This is necessary for loading a new ctags file or\ncompletions from a different project.\n@param The adeptsense returned by adeptsense.new().\n
complete _m.textadept.adeptsense.complete(sense, only_fields, only_functions)\nShows an autocompletion list for the symbol behind the caret.\n@param The adeptsense returned by adeptsense.new().\n@param If true, returns list of only fields; defaults to false.\n@param If true, returns list of only functions; defaults to false.\n@return true on success or false.\n@see get_symbol\n@see get_completions\n
get_apidoc _m.textadept.adeptsense.get_apidoc(sense, symbol)\nReturns a list of apidocs for the given symbol. If there are multiple apidocs,\nthe index of one to display is the value of the 'pos' key in the returned list.\n@param The adeptsense returned by adeptsense.new().\n@param The symbol to get apidocs for.\n@return apidoc_list or nil\n
get_class _m.textadept.adeptsense.get_class(sense, symbol)\nReturns the class name for a given symbol. If the symbol is sense.syntax.self\nand a class definition using the sense.syntax.class_definition keyword\nis found, that class is returned. Otherwise the buffer is searched\nbackwards for a type declaration of the symbol according to the patterns\nin sense.syntax.type_declarations.\n@param The adeptsense returned by adeptsense.new().\n@param The symbol to get the class of.\n@return class or nil\n@see syntax\n
get_completions _m.textadept.adeptsense.get_completions(sense, symbol, only_fields,\nonly_functions)\nReturns a list of completions for the given symbol.\n@param The adeptsense returned by adeptsense.new().\n@param The symbol to get completions for.\n@param If true, returns list of only fields; defaults to false.\n@param If true, returns list of only functions; defaults to false.\n@return completion_list or nil\n
get_symbol _m.textadept.adeptsense.get_symbol(sense)\nReturns a full symbol (if any) and current symbol part (if any) behind the\ncaret. For example: buffer.cur would return 'buffer' and 'cur'.\n@param The adeptsense returned by adeptsense.new().\n@return symbol or '', part or ''.\n
goto_ctag _m.textadept.adeptsense.goto_ctag(sense, k, title)\nDisplays a filteredlist of all known symbols of the given kind (classes,\nfunctions, fields, etc.) and jumps to the source of the selected one.\n@param The adeptsense returned by adeptsense.new().\n@param The ctag character kind (e.g. 'f' for a Lua function).\n@param The title for the filteredlist dialog.\n
handle_clear _m.textadept.adeptsense.handle_clear(sense)\nCalled when clearing an adeptsense. This function should be replaced with\nyour own if you have any persistant objects that need to be deleted.\n@param The adeptsense returned by adeptsense.new().\n
handle_ctag _m.textadept.adeptsense.handle_ctag(sense, tag_name, file_name, ex_cmd,\next_fields)\nCalled by load_ctags when a ctag kind is not recognized. This method should\nbe replaced with your own that is specific to the language.\n@param The adeptsense returned by adeptsense.new().\n@param The tag name.\n@param The name of the file the tag belongs to.\n@param The ex_cmd returned by ctags.\n@param The ext_fields returned by ctags.\n
load_ctags _m.textadept.adeptsense.load_ctags(sense, tag_file, nolocations)\nLoads the given ctags file for autocompletion. It is recommended to pass '-n'\nto ctags in order to use line numbers instead of text patterns to locate\ntags. This will greatly reduce memory usage for a large number of symbols\nif nolocations is not true.\n@param The adeptsense returned by adeptsense.new().\n@param The path of the ctags file to load.\n@param If true, does not store the locations of the tags for use by\ngoto_ctag(). Defaults to false.\n
new _m.textadept.adeptsense.new(lang)\nCreates a new adeptsense for the given lexer language. Only one sense can\nexist per language.\n@param The lexer language to create an adeptsense for.\n@usage local lua_sense = _m.textadept.adeptsense.new('lua')\n@return adeptsense.\n
show_apidoc _m.textadept.adeptsense.show_apidoc(sense)\nShows a calltip with API documentation for the symbol behind the caret.\n@param The adeptsense returned by adeptsense.new().\n@return true on success or false.\n@see get_symbol\n@see get_apidoc\n
always_show_globals _m.textadept.adeptsense.always_show_globals\nA flag indicating whether or not to include globals in the list of completions\noffered. Globals are classes, functions, and fields that do not belong to\nanother class. They are contained in `completions['']`. Defaults to true.\n
FUNCTIONS _m.textadept.adeptsense.FUNCTIONS\nXPM image for adeptsense functions.\n
FIELDS _m.textadept.adeptsense.FIELDS\nXPM image for adeptsense fields.\n
add _m.textadept.bookmarks.add()\nAdds a bookmark to the current line.\n
clear _m.textadept.bookmarks.clear()\nClears all bookmarks in the current buffer.\n
goto _m.textadept.bookmarks.goto()\nGoes to selected bookmark from a filtered list.\n
goto_next _m.textadept.bookmarks.goto_next()\nGoes to the next bookmark in the current buffer.\n
goto_prev _m.textadept.bookmarks.goto_prev()\nGoes to the previous bookmark in the current buffer.\n
remove _m.textadept.bookmarks.remove()\nClears the bookmark at the current line.\n
toggle _m.textadept.bookmarks.toggle()\nToggles a bookmark on the current line.\n
MARK_BOOKMARK _m.textadept.bookmarks.MARK_BOOKMARK\nThe unique integer mark used to identify a bookmarked\n line.\n\n
MARK_BOOKMARK_COLOR _m.textadept.bookmarks.MARK_BOOKMARK_COLOR\nThe Scintilla color used for a\n bookmarked line.\n\n
autocomplete_word _m.textadept.editing.autocomplete_word(word_chars)\nPops up an autocompletion list for the current word based on other words in\nthe document.\n@param String of chars considered to be part of words.\n@return true if there were completions to show; false otherwise.\n
block_comment _m.textadept.editing.block_comment(comment)\nBlock comments or uncomments code with a given comment string.\n@param The comment string inserted or removed from the beginning of each\nline in the selection.\n
convert_indentation _m.textadept.editing.convert_indentation()\nConverts indentation between tabs and spaces.\n
current_word _m.textadept.editing.current_word(action)\nSelects the current word under the caret and if action indicates, deletes it.\n@param Optional action to perform with selected word. If 'delete', it\nis deleted.\n
enclose _m.textadept.editing.enclose(left, right)\nEncloses text within a given pair of strings. If text is selected, it is\nenclosed. Otherwise, the previous word is enclosed.\n@param The left part of the enclosure.\n@param The right part of the enclosure.\n
goto_line _m.textadept.editing.goto_line(line)\nGoes to the requested line.\n@param Optional line number to go to.\n
grow_selection _m.textadept.editing.grow_selection(amount)\nGrows the selection by a character amount on either end.\n@param The amount to grow the selection on either end.\n
highlight_word _m.textadept.editing.highlight_word()\nHighlights all occurances of the word under the caret and adds markers to\nthe lines they are on.\n
join_lines _m.textadept.editing.join_lines()\nJoins the current line with the line below.\n
match_brace _m.textadept.editing.match_brace(select)\nGoes to a matching brace position, selecting the text inside if specified.\n@param If true, selects the text between matching braces.\n
prepare_for_save _m.textadept.editing.prepare_for_save()\nPrepares the buffer for saving to a file. Strips trailing whitespace off of\nevery line, ensures an ending newline, and converts non-consistent EOLs.\n
select_enclosed _m.textadept.editing.select_enclosed(left, right)\nSelects text between a given pair of strings.\n@param The left part of the enclosure.\n@param The right part of the enclosure.\n
select_indented_block _m.textadept.editing.select_indented_block()\nSelects indented blocks intelligently. If no block of text is selected, all\ntext with the current level of indentation is selected. If a block of text is\nselected and the lines to the top and bottom of it are one indentation level\nlower, they are added to the selection. In all other cases, the behavior is\nthe same as if no text is selected.\n
select_line _m.textadept.editing.select_line()\nSelects the current line.\n
select_paragraph _m.textadept.editing.select_paragraph()\nSelects the current paragraph. Paragraphs are delimited by two or more\nconsecutive newlines.\n
select_scope _m.textadept.editing.select_scope()\nSelects all text with the same style as under the caret.\n
transpose_chars _m.textadept.editing.transpose_chars()\nTransposes characters intelligently. If the caret is at the end of a line,\nthe two characters before the caret are transposed. Otherwise, the characters\nto the left and right are.\n
AUTOPAIR _m.textadept.editing.AUTOPAIR\nFlag indicating whether or not when an opening `(`, `[`, `[`, `"`, or `'`\nis typed, its closing complement character is automatically inserted.\n
HIGHLIGHT_BRACES _m.textadept.editing.HIGHLIGHT_BRACES\nFlag indicating whether or not when the caret is over a brace character (any\nof the following: `()[]{}<>`), its matching complement brace is highlighted.\n
AUTOINDENT _m.textadept.editing.AUTOINDENT\nFlag indicating whether or not when the enter key is pressed, the inserted\nline has is indented to match the level of indentation of the previous line.\n
SAVE_STRIPS_WS _m.textadept.editing.SAVE_STRIPS_WS\nFlag indicating whether or not to strip trailing whitespace on file save.\n
MARK_HIGHLIGHT _m.textadept.editing.MARK_HIGHLIGHT\nThe unique integer mark used to identify a line containing a highlighted word.\n
MARK_HIGHLIGHT_BACK _m.textadept.editing.MARK_HIGHLIGHT_BACK\nThe Scintilla color used for a line containing a highlighted word.\n
INDIC_HIGHLIGHT _m.textadept.editing.INDIC_HIGHLIGHT\nThe unique integer indicator for highlighted words.\n
INDIC_HIGHLIGHT_BACK _m.textadept.editing.INDIC_HIGHLIGHT_BACK\nThe Scintilla color used for an indicator for a highlighted word.\n
INDIC_HIGHLIGHT_ALPHA _m.textadept.editing.INDIC_HIGHLIGHT_ALPHA\nThe transparency used for an indicator for a highlighted word.\n
filter_through _m.textadept.filter_through.filter_through()\nPrompts for a Linux, Mac OSX, or Windows shell command to filter text\nthrough. The standard input (stdin) for shell commands is determined as\nfollows: (1) If text is selected and spans multiple lines, all text on the\nlines containing the selection is used. However, if the end of the selection\nis at the beginning of a line, only the EOL (end of line) characters from the\nprevious line are included as input. The rest of the line is excluded. (2) If\ntext is selected and spans a single line, only the selected text is used. (3)\nIf no text is selected, the entire buffer is used. The input text is replaced\nwith the standard output (stdout) of the command.\n
set_contextmenu _m.textadept.menu.set_contextmenu(menu_table)\nSets gui.context_menu from the given menu table.\n@param The menu table to create the context menu from. Each table entry is\neither a submenu or menu text and an action table.\n@see set_menubar\n
set_menubar _m.textadept.menu.set_menubar(menubar)\nSets gui.menubar from the given table of menus.\n@param The table of menus to create the menubar from. Each table entry\nis another table that corresponds to a particular menu. A menu can have a\n'title' key with string value. Each menu item is either a submenu (another\nmenu table) or a table consisting of two items: string menu text and an action\ntable just like `_G.keys`'s action table. If the menu text is 'separator',\na menu separator is created and no action table is required.\n
select_lexer _m.textadept.mime_types.select_lexer()\nPrompts the user to select a lexer from a filtered list for the current buffer.\n
compile _m.textadept.run.compile()\nCompiles the file as specified by its extension in the compile_command table.\n@see compile_command\n
execute _m.textadept.run.execute(command)\nExecutes the command line parameter and prints the output to Textadept.\n@param The command line string. It can have the following macros: *\n%(filepath) The full path of the current file. * %(filedir) The current file's\ndirectory path. * %(filename) The name of the file including extension. *\n%(filename_noext) The name of the file excluding extension.\n
goto_error _m.textadept.run.goto_error(pos, line_num)\nWhen the user double-clicks an error message, go to the line in the file\nthe error occured at and display a calltip with the error message.\n@param The position of the caret.\n@param The line double-clicked.\n@see error_detail\n
run _m.textadept.run.run()\nRuns/executes the file as specified by its extension in the run_command table.\n@see run_command\n
load _m.textadept.session.load(filename)\nLoads a Textadept session file. Textadept restores split views, opened buffers,\ncursor information, and project manager details.\n@param The absolute path to the session file to load. Defaults to\nDEFAULT_SESSION if not specified.\n@usage _m.textadept.session.load(filename)\n@return true if the session file was opened and read; false otherwise.\n
save _m.textadept.session.save(filename)\nSaves a Textadept session to a file. Saves split views, opened buffers,\ncursor information, and project manager details.\n@param The absolute path to the session file to save. Defaults to either\nthe current session file or DEFAULT_SESSION if not specified.\n@usage _m.textadept.session.save(filename)\n
DEFAULT_SESSION _m.textadept.session.DEFAULT_SESSION\nThe path to the default session file.\n
SAVE_ON_QUIT _m.textadept.session.SAVE_ON_QUIT\nSave the session when quitting. Defaults to true and can be disabled by\npassing the command line switch '-n' or '--nosession' to Textadept.\n
open _m.textadept.snapopen.open(utf8_paths, filter, exclusive, depth)\nQuickly open a file in set of directories.\n@param A UTF-8 string directory path or table of UTF-8 directory paths\nto search.\n@param A filter for files and folders to exclude. The filter may be a string\nor table. Each filter is a Lua pattern. Any files matching a filter are\nexcluded. Prefix a pattern with '!' to exclude any files that do not match\nthe filter. Directories can be excluded by adding filters to a table assigned\nto a 'folders' key in the filter table. All strings should be UTF-8 encoded.\n@param Flag indicating whether or not to exclude PATHS in the search. Defaults\nto false.\n@param Number of directories to recurse into for finding files. Defaults\nto DEFAULT_DEPTH.\n@usage _m.textadept.snapopen.open()\n@usage _m.textadept.snapopen.open(buffer.filename:match('^.+/'), nil, true)\n@usage _m.textadept.snapopen.open(nil, '!%.lua$')\n@usage _m.textadept.snapopen.open(nil, { folders = { '%.hg' } })\n
PATHS _m.textadept.snapopen.PATHS\nTable of default UTF-8 paths to search.\n
DEFAULT_DEPTH _m.textadept.snapopen.DEFAULT_DEPTH\nMaximum directory depth to search (defaults to 4).\n
MAX _m.textadept.snapopen.MAX\nMaximum number of files to list (defaults to 1000).\n
_cancel_current _m.textadept.snippets._cancel_current()\nCancels the active snippet, reverting to the state before its activation,\nand restores the previously running snippet (if any).\n
_insert _m.textadept.snippets._insert(text)\nInserts a snippet.\n@param Optional snippet text. If none is specified, the snippet text is\ndetermined from the trigger and lexer.\n@return false if no snippet was expanded; true otherwise.\n
_previous _m.textadept.snippets._previous()\nGoes back to the previous placeholder, reverting any changes from the\ncurrent one.\n@return false if no snippet is active; nil otherwise.\n
_select _m.textadept.snippets._select()\nPrompts the user to select a snippet to insert from a filtered list\ndialog. Global snippets and snippets in the current lexer are shown.\n
INDIC_SNIPPET _m.textadept.snippets.INDIC_SNIPPET\nThe unique integer indicator used to mark the end of a snippet.\n
process args.process()\nProcesses command line arguments. Add command line switches with\nargs.register(). Any unrecognized arguments are treated as filepaths and\nopened. Generates an 'arg_none' event when no args are present.\n@see register\n
register args.register(switch1, switch2, narg, f, description)\nRegisters a command line switch.\n@param String switch (short version).\n@param String switch (long version).\n@param The number of expected parameters for the switch.\n@param The Lua function to run when the switch is tripped.\n@param Description of the switch.\n
add_selection buffer.add_selection(buffer, caret, anchor)\nAdds a new selection from anchor to caret as the main selection. All other\nselections are retained as additional selections.\n
add_text buffer.add_text(buffer, text)\nAdds text to the document at the current position.\n
add_undo_action buffer.add_undo_action(buffer, token, flags)\nAdds an action to the undo stack.\n
allocate buffer.allocate(buffer, bytes)\nEnlarges the document to a particular size of text bytes\n
annotation_clear_all buffer.annotation_clear_all(buffer)\nClears all lines of annotations.\n
annotation_get_styles buffer.annotation_get_styles(buffer, line)\nReturns the styles of the annotation for the given line.\n
annotation_get_text buffer.annotation_get_text(buffer, line)\nReturns the annotation text for the given line.\n
annotation_set_styles buffer.annotation_set_styles(buffer, line, styles)\nSets the styled annotation text for the given line.\n
annotation_set_text buffer.annotation_set_text(buffer, line, text)\nSets the annotation text for the given line.\n
append_text buffer.append_text(buffer, text)\nAppends a string to the end of the document without changing the selection.\n
auto_c_active buffer.auto_c_active(buffer)\nReturns a flag indicating whether or not an autocompletion list is visible.\n
auto_c_cancel buffer.auto_c_cancel(buffer)\nRemoves the autocompletion list from the screen.\n
auto_c_complete buffer.auto_c_complete(buffer)\nItem selected; removes the list and insert the selection.\n
auto_c_get_current buffer.auto_c_get_current(buffer)\nReturns the currently selected item position in the autocompletion list.\n
auto_c_get_current_text buffer.auto_c_get_current_text(buffer)\nReturns the currently selected text in the autocompletion list.\n
auto_c_pos_start buffer.auto_c_pos_start(buffer)\nReturns the position of the caret when the autocompletion list was shown.\n
auto_c_select buffer.auto_c_select(buffer, string)\nSelects the item in the autocompletion list that starts with a string.\n
auto_c_show buffer.auto_c_show(buffer, len_entered, item_list)\nDisplays an autocompletion list.\n@param The number of characters before the caret used to provide the context.\n@param String if completion items separated by spaces.\n
auto_c_stops buffer.auto_c_stops(buffer, chars)\nDefines a set of characters that why typed cancel the autocompletion list.\n
back_tab buffer.back_tab(buffer)\nDedents selected lines.\n
begin_undo_action buffer.begin_undo_action(buffer)\nStarts a sequence of actions that are undone/redone as a unit.\n
brace_bad_light buffer.brace_bad_light(buffer, pos)\nHighlights the character at a position indicating there's no matching brace.\n
brace_highlight buffer.brace_highlight(buffer, pos1, pos2)\nHighlights the characters at two positions as matching braces.\n
brace_match buffer.brace_match(buffer, pos)\nReturns the position of a matching brace at a position or -1.\n
call_tip_active buffer.call_tip_active(buffer)\nReturns a flag indicating whether or not a call tip is active.\n
call_tip_cancel buffer.call_tip_cancel(buffer)\nRemoves the call tip from the screen.\n
call_tip_pos_start buffer.call_tip_pos_start(buffer)\nReturns the position where the caret was before showing the call tip.\n
call_tip_set_hlt buffer.call_tip_set_hlt(buffer, start_pos, end_pos)\nHighlights a segment of a call tip.\n
call_tip_show buffer.call_tip_show(buffer, pos, text)\nShows a call tip containing text at or near a position.\n
can_paste buffer.can_paste(buffer)\nReturns a flag indicating whether or not a paste will succeed.\n
can_redo buffer.can_redo(buffer)\nReturns a flag indicating whether or not there are redoable actions in the\nundo history.\n
can_undo buffer.can_undo(buffer)\nReturns a flag indicating whether or not there are redoable actions in the\nundo history.\n
cancel buffer.cancel(buffer)\nCancels any modes such as call tip or autocompletion list display.\n
change_lexer_state buffer.change_lexer_state(buffer, start_pos, end_pos)\nIndicate that the internal state of a lexer has changed over a range and\ntherefore there may be a need to redraw.\n
char_left buffer.char_left(buffer)\nMoves the caret left one character.\n
char_left_extend buffer.char_left_extend(buffer)\nMoves the caret left one character, extending the selection.\n
char_left_rect_extend buffer.char_left_rect_extend(buffer)\nMoves the caret left one character, extending the rectangular selection.\n
char_position_from_point buffer.char_position_from_point(buffer, x, y)\nFinds the closest character to a point.\n
char_position_from_point_close buffer.char_position_from_point_close(buffer, x, y)\nFinds the closest character to a point, but returns -1 if the given point\nis outside the window or not close to any characters.\n
char_right buffer.char_right(buffer)\nMoves the caret right one character.\n
char_right_extend buffer.char_right_extend(buffer)\nMoves the caret right one character, extending the selection.\n
char_right_rect_extend buffer.char_right_rect_extend(buffer)\nMoves the caret right one character, extending the rectangular selection.\n
choose_caret_x buffer.choose_caret_x(buffer)\nSets the last x chosen value to be the caret x position.\n
clear buffer.clear(buffer)\nClears the selection.\n
clear_all buffer.clear_all(buffer)\nDeletes all text in the document.\n
clear_all_cmd_keys buffer.clear_all_cmd_keys(buffer)\nDrops all key mappings.\n
clear_document_style buffer.clear_document_style(buffer)\nSets all style bytes to 0, remove all folding information.\n
clear_registered_images buffer.clear_registered_images(buffer)\nClears all the registered XPM images.\n
clear_selections buffer.clear_selections(buffer)\nClears all selections.\n
close buffer.close(buffer)\nCloses the current buffer.\n@param The focused buffer. If the buffer is dirty, the user is prompted to\ncontinue. The buffer is not saved automatically. It must be done manually.\n
colourise buffer.colourise(buffer, start_pos, end_pos)\nColorizes a segment of the document using the current lexing language.\n
contracted_fold_next buffer.contracted_fold_next(buffer, line_start)\nReturns the first line in a contracted fold state starting from line_start\nor -1 when the end of the file is reached.\n
convert_eo_ls buffer.convert_eo_ls(buffer, mode)\nConverts all line endings in the document to one mode.\n@param The line ending mode. 0: CRLF, 1: CR, 2: LF.\n
copy buffer.copy(buffer)\nCopies the selection to the clipboard.\n
copy_allow_line buffer.copy_allow_line(buffer)\nCopies the selection to the clipboard or the current line.\n
copy_range buffer.copy_range(buffer, start_pos, end_pos)\nCopies a range of text to the clipboard.\n
copy_text buffer.copy_text(buffer, text)\nCopies argument text to the clipboard.\n
cut buffer.cut(buffer)\nCuts the selection to the clipboard.\n
del_line_left buffer.del_line_left(buffer)\nDeletes back from the current position to the start of the line.\n
del_line_right buffer.del_line_right(buffer)\nDeletes forwards from the current position to the end of the line.\n
del_word_left buffer.del_word_left(buffer)\nDeletes the word to the left of the caret.\n
del_word_right buffer.del_word_right(buffer)\nDeletes the word to the right of the caret.\n
del_word_right_end buffer.del_word_right_end(buffer)\nDeletes the word to the right of the caret to its end.\n
delete buffer.delete(buffer)\nDeletes the current buffer. WARNING: this function should NOT be called via\nscripts. io provides a close() function for buffers to prompt for confirmation\nif necessary; this function does not. Activates the 'buffer_deleted' signal.\n@param The focused buffer.\n
delete_back buffer.delete_back(buffer)\nDeletes the selection or the character before the caret.\n
delete_back_not_line buffer.delete_back_not_line(buffer)\nDeletes the selection or the character before the caret. Will not delete\nthe character before at the start of a lone.\n
describe_key_word_sets buffer.describe_key_word_sets(buffer)\nRetrieve a '\\n' separated list of descriptions of the keyword sets understood\nby the current lexer.\n
describe_property buffer.describe_property(buffer, name)\nDescribe a property.\n
doc_line_from_visible buffer.doc_line_from_visible(buffer)\nReturns the document line of a display line taking hidden lines into account.\n
document_end buffer.document_end(buffer)\nMoves the caret to the last position in the document.\n
document_end_extend buffer.document_end_extend(buffer)\nMoves the caret to the last position in the document, extending the selection.\n
document_start buffer.document_start(buffer)\nMoves the caret to the first position in the document.\n
document_start_extend buffer.document_start_extend(buffer)\nMoves the caret to the first position in the document, extending the selection.\n
edit_toggle_overtype buffer.edit_toggle_overtype(buffer)\nSwitches from insert to overtype mode or the reverse.\n
empty_undo_buffer buffer.empty_undo_buffer(buffer)\nDeletes the undo history.\n
encoded_from_utf8 buffer.encoded_from_utf8(buffer, string)\nTranslates a UTF8 string into the document encoding and returns its length.\n
end_undo_action buffer.end_undo_action(buffer)\nEnds a sequence of actions that is undone/redone as a unit.\n
ensure_visible buffer.ensure_visible(buffer, line)\nEnsures a particular line is visible by expanding any header line hiding it.\n
ensure_visible_enforce_policy buffer.ensure_visible_enforce_policy(buffer, line)\nEnsures a particular line is visible by expanding any header line hiding\nit. Uses the currently set visible policy to determine which range to display.\n
find_column buffer.find_column(buffer, line, column)\nReturns the position of the column on a line taking into account tabs and\nmulti-byte characters or the line end position.\n
form_feed buffer.form_feed(buffer)\nInserts a form feed character.\n
get_cur_line buffer.get_cur_line(buffer)\nReturns the text of the line containing the caret and the index of the caret\non the line.\n
get_hotspot_active_back buffer.get_hotspot_active_back(buffer)\nReturns the background color for active hotspots.\n
get_hotspot_active_fore buffer.get_hotspot_active_fore(buffer)\nReturns the foreground color for active hotspots.\n
get_last_child buffer.get_last_child(buffer, header_line, level)\nReturns the last child line of a header line.\n
get_lexer buffer.get_lexer(buffer)\nReplacement for buffer.get_lexer_language(buffer, ).\n@param The focused buffer.\n
get_lexer_language buffer.get_lexer_language(buffer)\nReturns the name of the lexing language used by the document.\n
get_line buffer.get_line(buffer, line)\nReturns the contents of a line.\n
get_line_sel_end_position buffer.get_line_sel_end_position(buffer, line)\nReturns the position of the end of the selection at the given line or -1.\n
get_line_sel_start_position buffer.get_line_sel_start_position(buffer, line)\nReturns the position of the start of the selection at the given line or -1.\n
get_property buffer.get_property(buffer, property)\nReturns the value of a property.\n
get_property_expanded buffer.get_property_expanded(buffer)\nReturns the value of a property with "$()" variable replacement.\n
get_sel_text buffer.get_sel_text(buffer)\nReturns the selected text.\n
get_style_name buffer.get_style_name(buffer, style_num)\nReturns the name of the style associated with a style number.\n@param The focused buffer.\n@param A style number in the range 0 <= style_num < 256.\n@see buffer.style_at\n
get_tag buffer.get_tag(buffer, tag_num)\nReturns the text matched by a tagged expression in a regexp search.\n
get_text buffer.get_text(buffer)\nReturns all text in the document and its length.\n
goto_line buffer.goto_line(buffer, line)\nSets the caret to the start of a line and ensure it is visible.\n
goto_pos buffer.goto_pos(buffer, pos)\nSets the caret to a position and ensure it is visible.\n
grab_focus buffer.grab_focus(buffer)\nSets the focus to this Scintilla widget.\n
hide_lines buffer.hide_lines(buffer, start_line, end_line)\nMakes a range of lines invisible.\n
hide_selection buffer.hide_selection(buffer, normal)\nDraws the selection in normal style or with the selection highlighted.\n
home buffer.home(buffer)\nMoves the caret to the first position on the current line.\n
home_display buffer.home_display(buffer)\nMoves the caret to the first position on the display line.\n
home_display_extend buffer.home_display_extend(buffer)\nMoves the caret to the first position on the display line, extending the\nselection.\n
home_extend buffer.home_extend(buffer)\nMoves the caret to the first position on the current line, extending the\nselection.\n
home_rect_extend buffer.home_rect_extend(buffer)\nMoves the caret to the first position on the current line, extending the\nrectangular selection.\n
home_wrap buffer.home_wrap(buffer)\nMoves the caret to the start of the current display line and then the document\nline. (If word wrap is enabled)\n
home_wrap_extend buffer.home_wrap_extend(buffer)\nMoves the caret to the start of the current display line and then the document\nline, extending the selection. (If word wrap is enabled)\n
indicator_all_on_for buffer.indicator_all_on_for(buffer, pos)\nReturns a flag indicating whether or not any indicators are present at the\nspecified position.\n
indicator_clear_range buffer.indicator_clear_range(buffer, pos, clear_length)\nTurns an indicator off over a range.\n
indicator_end buffer.indicator_end(buffer, indicator, pos)\nReturns the position where a particular indicator ends.\n
indicator_fill_range buffer.indicator_fill_range(buffer, pos, fill_length)\nTurns an indicator on over a range.\n
indicator_start buffer.indicator_start(buffer, indicator, pos)\nReturns the position where a particular indicator starts.\n
indicator_value_at buffer.indicator_value_at(buffer, indicator, pos)\nReturns the value of a particular indicator at the specified position.\n
insert_text buffer.insert_text(buffer, pos, text)\nInserts text at a position. -1 is the document's length.\n
line_copy buffer.line_copy(buffer)\nCopies the line containing the caret.\n
line_cut buffer.line_cut(buffer)\nCuts the line containing the caret.\n
line_delete buffer.line_delete(buffer)\nDeletes the line containing the caret.\n
line_down buffer.line_down(buffer)\nMoves the caret down one line.\n
line_down_extend buffer.line_down_extend(buffer)\nMoves the caret down one line, extending the selection.\n
line_down_rect_extend buffer.line_down_rect_extend(buffer)\nMoves the caret down one line, extending the rectangular selection.\n
line_duplicate buffer.line_duplicate(buffer)\nDuplicates the current line.\n
line_end buffer.line_end(buffer)\nMoves the caret to the last position on the current line.\n
line_end_display buffer.line_end_display(buffer)\nMoves the caret to the last position on the display line.\n
line_end_display_extend buffer.line_end_display_extend(buffer)\nMoves the caret to the last position on the display line, extending the\nselection.\n
line_end_extend buffer.line_end_extend(buffer)\nMoves the caret to the last position on the current line, extending the\nselection.\n
line_end_rect_extend buffer.line_end_rect_extend(buffer)\nMoves the caret to the last position on the current line, extending the\nrectangular selection.\n
line_end_wrap buffer.line_end_wrap(buffer)\nMoves the caret to the last position on the current display line and then\nthe document line. (If wrap mode is enabled)\n
line_end_wrap_extend buffer.line_end_wrap_extend(buffer)\nMoves the caret to the last position on the current display line and then\nthe document line, extending the selection. (If wrap mode is enabled)\n
line_from_position buffer.line_from_position(buffer, pos)\nReturns the line containing the position.\n
line_length buffer.line_length(buffer, line)\nReturns the length of the specified line including EOL characters.\n
line_scroll buffer.line_scroll(buffer, columns, lines)\nScrolls horizontally and vertically the number of columns and lines.\n
line_scroll_down buffer.line_scroll_down(buffer)\nScrolls the document down, keeping the caret visible.\n
line_scroll_up buffer.line_scroll_up(buffer)\nScrolls the document up, keeping the caret visible.\n
line_transpose buffer.line_transpose(buffer)\nSwitches the current line with the previous.\n
line_up buffer.line_up(buffer)\nMoves the caret up one line.\n
line_up_extend buffer.line_up_extend(buffer)\nMoves the caret up one line, extending the selection.\n
line_up_rect_extend buffer.line_up_rect_extend(buffer)\nMoves the caret up one line, extending the rectangular selection.\n
lines_join buffer.lines_join(buffer)\nJoins the lines in the target.\n
lines_split buffer.lines_split(buffer, pixel_width)\nSplits lines in the target into lines that are less wide that pixel_width\nwhere possible.\n
load_lexer_library buffer.load_lexer_library(buffer, path)\nLoads a lexer library (dll/so)\n
lower_case buffer.lower_case(buffer)\nTransforms the selection to lower case.\n
margin_get_styles buffer.margin_get_styles(buffer, line)\nReturns the styled margin text for the given line.\n
margin_get_text buffer.margin_get_text(buffer, line)\nReturns the margin text for the given line.\n
margin_set_styles buffer.margin_set_styles(buffer, line, styles)\nSets the styled margin text for the given line.\n
margin_set_text buffer.margin_set_text(buffer, line, text)\nSets the margin text for the given line.\n
margin_text_clear_all buffer.margin_text_clear_all(buffer)\nClears all margin text.\n
marker_add buffer.marker_add(buffer, line, marker_num)\nAdds a marker to a line, returning an ID which can be used to find or delete\nthe marker.\n
marker_add_set buffer.marker_add_set(buffer, line, set)\nAdds a set of markers to a line.\n
marker_define buffer.marker_define(buffer, marker_num, marker_symbol)\nSets the symbol used for a particular marker number.\n
marker_define_pixmap buffer.marker_define_pixmap(buffer, marker_num, pixmap)\nDefines a marker from a pixmap.\n
marker_delete buffer.marker_delete(buffer, line, marker_num)\nDeletes a marker from a line.\n
marker_delete_all buffer.marker_delete_all(buffer, marker_num)\nDeletes all markers with a particular number from all lines.\n
marker_delete_handle buffer.marker_delete_handle(buffer, handle)\nDeletes a marker.\n
marker_get buffer.marker_get(buffer, line)\nGets a bit mask of all the markers set on a line.\n
marker_line_from_handle buffer.marker_line_from_handle(buffer, handle)\nReturns the line number at which a particular marker is located.\n
marker_next buffer.marker_next(buffer, start_line, marker_mask)\nFinds the next line after start_line that includes a marker in marker_mask.\n
marker_previous buffer.marker_previous(buffer, start_line, marker_mask)\nFinds the previous line after start_line that includes a marker in marker_mask.\n
marker_set_alpha buffer.marker_set_alpha(buffer, marker_num, alpha)\nSets the alpha used for a marker that is drawn in the text area, not the\nmargin.\n
marker_set_back buffer.marker_set_back(buffer, marker_num, color)\nSets the background color used for a particular marker number.\n
marker_set_fore buffer.marker_set_fore(buffer, marker_num, color)\nSets the foreground color used for a particular marker number.\n
marker_symbol_defined buffer.marker_symbol_defined(buffer, marker_number)\nReturns the symbol defined for the given marker_number.\n
move_caret_inside_view buffer.move_caret_inside_view(buffer)\nMoves the caret inside the current view if it's not there already.\n
new_line buffer.new_line(buffer)\nInserts a new line depending on EOL mode.\n
null buffer.null(buffer)\nNull operation\n
page_down buffer.page_down(buffer)\nMoves the caret one page down.\n
page_down_extend buffer.page_down_extend(buffer)\nMoves the caret one page down, extending the selection.\n
page_down_rect_extend buffer.page_down_rect_extend(buffer)\nMoves the caret one page down, extending the rectangular selection.\n
page_up buffer.page_up(buffer)\nMoves the caret one page up.\n
page_up_extend buffer.page_up_extend(buffer)\nMoves the caret one page up, extending the selection.\n
page_up_rect_extend buffer.page_up_rect_extend(buffer)\nMoves the caret one page up, extending the rectangular selection.\n
para_down buffer.para_down(buffer)\nMoves the caret one paragraph down (delimited by empty lines).\n
para_down_extend buffer.para_down_extend(buffer)\nMoves the caret one paragraph down (delimited by empty lines), extending\nthe selection.\n
para_up buffer.para_up(buffer)\nMoves the caret one paragraph up (delimited by empty lines).\n
para_up_extend buffer.para_up_extend(buffer)\nMoves the caret one paragraph up (delimited by empty lines), extending\nthe selection.\n
paste buffer.paste(buffer)\nPastes the contents of the clipboard into the document replacing the selection.\n
point_x_from_position buffer.point_x_from_position(buffer, pos)\nReturns the x value of the point in the window where a position is shown.\n
point_y_from_position buffer.point_y_from_position(buffer, pos)\nReturns the y value of the point in the window where a position is shown.\n
position_after buffer.position_after(buffer, pos)\nReturns the next position in the document taking code page into account.\n
position_before buffer.position_before(buffer, pos)\nReturns the previous position in the document taking code page into account.\n
position_from_line buffer.position_from_line(buffer, line)\nReturns the position at the start of the specified line.\n
position_from_point buffer.position_from_point(buffer, x, y)\nReturns the position from a point within the window.\n
position_from_point_close buffer.position_from_point_close(buffer, x, y)\nReturns the position from a point within the window, but return -1 if not\nclose to text.\n
private_lexer_call buffer.private_lexer_call(buffer, operation)\nFor private communication between an application and a known lexer.\n
property_names buffer.property_names(buffer)\nRetrieve a '\\n' separated list of properties understood by the current lexer.\n
property_type buffer.property_type(buffer, name)\nRetrieve the type of a property.\n
redo buffer.redo(buffer)\nRedoes the next action in the undo history.\n
register_image buffer.register_image(buffer, type, xmp_data)\nRegisters and XPM image for use in autocompletion lists.\n
reload buffer.reload(buffer)\nReloads the file in a given buffer.\n
replace_sel buffer.replace_sel(buffer, text)\nReplaces the selected text with the argument text.\n
replace_target buffer.replace_target(buffer, text)\nReplaces the target text with the argument text.\n
replace_target_re buffer.replace_target_re(buffer, text)\nReplaces the target text with the argument text after \d processing. Looks\nfor \d where d is 1-9 and replaces it with the strings captured by a previous\nRE search.\n
rotate_selection buffer.rotate_selection(buffer)\nMakes the next selection the main selection.\n
save buffer.save(buffer)\nSaves the current buffer to a file.\n@param The focused buffer.\n
save_as buffer.save_as(buffer, utf8_filename)\nSaves the current buffer to a file different than its filename property.\n@param The focused buffer.\n@param The new filepath to save the buffer to. Must be UTF-8 encoded.\n
scroll_caret buffer.scroll_caret(buffer)\nEnsures the caret is visible.\n
search_anchor buffer.search_anchor(buffer)\nSets the current caret position to be the search anchor.\n
search_in_target buffer.search_in_target(buffer, text)\nSearches for a string in the target and sets the target to the found range,\nreturning the length of the range or -1.\n
search_next buffer.search_next(buffer, flags, text)\nFinds some text starting at the search anchor. (Does not scroll selection)\n@param Mask of search flags. 2: whole word, 4: match case, 0x00100000:\nword start, 0x00200000 regexp, 0x00400000: posix.\n
search_prev buffer.search_prev(buffer, flags, text)\nFinds some text starting at the search anchor and moving backwards. (Does\nnot scroll the selection)\n@param Mask of search flags. 2: whole word, 4: match case, 0x00100000:\nword start, 0x00200000 regexp, 0x00400000: posix.\n
select_all buffer.select_all(buffer)\nSelects all the text in the document.\n
selection_duplicate buffer.selection_duplicate(buffer)\nDuplicates the selection or the line containing the caret.\n
set_chars_default buffer.set_chars_default(buffer)\nResets the set of characters for whitespace and word characters to the\ndefaults.\n
set_encoding buffer.set_encoding(buffer, encoding)\nSets the encoding for the buffer, converting its contents in the process.\n@param The focused buffer.\n@param The encoding to set. Valid encodings are ones that GTK's g_convert()\nfunction accepts (typically GNU iconv's encodings).\n@usage buffer.set_encoding(buffer, 'ASCII')\n
set_fold_flags buffer.set_fold_flags(buffer, flags)\nSets some style options for folding.\n@param Mask of fold flags. 0x0002: line before expanded, 0x0004: line before\ncontracted, 0x0008: line after expanded, 0x0010: line after contracted,\n0x0040: level numbers, 0x0001: box.\n
set_fold_margin_colour buffer.set_fold_margin_colour(buffer, use_setting, color)\nSets the background color used as a checkerboard pattern in the fold margin.\n
set_fold_margin_hi_colour buffer.set_fold_margin_hi_colour(buffer, use_setting, color)\nSets the foreground color used as a checkerboard pattern in the fold margin.\n
set_hotspot_active_back buffer.set_hotspot_active_back(buffer, use_setting, color)\nSets a background color for active hotspots.\n
set_hotspot_active_fore buffer.set_hotspot_active_fore(buffer, use_setting, color)\nSets a foreground color for active hotspots.\n
set_length_for_encode buffer.set_length_for_encode(buffer, bytes)\nSets the length of the utf8 argument for calling encoded_from_utf8.\n
set_lexer buffer.set_lexer(buffer, lang)\nReplacement for buffer.set_lexer_language(buffer, ). Sets a buffer._lexer\nfield so it can be restored without querying the mime-types tables. Also\nif the user manually sets the lexer, it should be restored. Loads the\nlanguage-specific module if it exists.\n@param The focused buffer.\n@param The string language to set.\n@usage buffer.set_lexer(buffer, 'language_name')\n
set_lexer_language buffer.set_lexer_language(buffer, language_name)\nSets the lexer language to the specified name.\n
set_save_point buffer.set_save_point(buffer)\nRemembers the current position in the undo history as the position at which\nthe document was saved.\n
set_sel buffer.set_sel(buffer, start_pos, end_pos)\nSelects a range of text.\n
set_sel_back buffer.set_sel_back(buffer, use_setting, color)\nSets the background color of the selection and whether to use this setting.\n
set_sel_fore buffer.set_sel_fore(buffer, use_setting, color)\nSets the foreground color of the selection and whether to use this setting.\n
set_selection buffer.set_selection(buffer, caret, anchor)\nSet a single selection from anchor to caret as the only selection.\n
set_styling buffer.set_styling(buffer, length, style)\nChanges the style from the current styling position for a length of characters\nto a style and move the current styling position to after this newly styled\nsegment.\n
set_styling_ex buffer.set_styling_ex(buffer, length, styles)\nSets the styles for a segment of the document.\n
set_text buffer.set_text(buffer, text)\nReplaces the contents of the document with the argument text.\n
set_visible_policy buffer.set_visible_policy(buffer, visible_policy, visible_slop)\nSets the way the display area is determined when a particular line is to be\nmoved to by find, find_next, goto_line, etc.\n@param 0x01: slop, 0x04: strict.\n@param 0x01: slop, 0x04: strict.\n
set_whitespace_back buffer.set_whitespace_back(buffer, use_setting, color)\nSets the background color of all whitespace and whether to use this setting.\n
set_whitespace_fore buffer.set_whitespace_fore(buffer, use_setting, color)\nSets the foreground color of all whitespace and whether to use this setting.\n
set_x_caret_policy buffer.set_x_caret_policy(buffer, caret_policy, caret_slop)\nSets the way the caret is kept visible when going side-ways.\n@param 0x01: slop, 0x04: strict, 0x10: jumps, 0x08: even.\n
set_y_caret_policy buffer.set_y_caret_policy(buffer, caret_policy, caret_slop)\nSets the way the line the caret is visible on is kept visible.\n@param 0x01: slop, 0x04: strict, 0x10: jumps, 0x08: even.\n
show_lines buffer.show_lines(buffer, start_line, end_line)\nMakes a range of lines visible.\n
start_record buffer.start_record(buffer)\nStarts notifying the container of all key presses and commands.\n
start_styling buffer.start_styling(buffer, position, mask)\nSets the current styling position to pos and the styling mask to mask.\n
stop_record buffer.stop_record(buffer)\nStops notifying the container of all key presses and commands.\n
stuttered_page_down buffer.stuttered_page_down(buffer)\nMoves caret to the bottom of the page, or one page down if already there.\n
stuttered_page_down_extend buffer.stuttered_page_down_extend(buffer)\nMoves caret to the bottom of the page, or one page down if already there,\nextending the selection.\n
stuttered_page_up buffer.stuttered_page_up(buffer)\nMoves caret to the top of the page, or one page up if already there.\n
stuttered_page_up_extend buffer.stuttered_page_up_extend(buffer)\nMoves caret to the top of the page, or one page up if already there, extending\nthe selection.\n
style_clear_all buffer.style_clear_all(buffer)\nResets all styles to the global default style.\n
style_get_font buffer.style_get_font(buffer, style_num)\nReturns the font name of a given style.\n
style_reset_default buffer.style_reset_default(buffer)\nResets the default style to its state at startup.\n
swap_main_anchor_caret buffer.swap_main_anchor_caret(buffer)\nMoves the caret to the opposite end of the main selection.\n
tab buffer.tab(buffer)\nInserts a tab character or indent multiple lines.\n
target_as_utf8 buffer.target_as_utf8(buffer)\nReturns the target converted to utf8.\n
target_from_selection buffer.target_from_selection(buffer)\nMakes the target range the same as the selection range.\n
text_height buffer.text_height(buffer, line)\nReturns the height of a particular line of text in pixels.\n
text_range buffer.text_range(buffer, start_pos, end_pos)\nGets a range of text from the current buffer.\n@param The currently focused buffer.\n@param The beginning position of the range of text to get.\n@param The end position of the range of text to get.\n
text_width buffer.text_width(buffer, style_num, text)\nReturns the pixel width of some text in a particular style.\n
toggle_caret_sticky buffer.toggle_caret_sticky(buffer)\nSwitches the caret between sticky and non-sticky.\n
toggle_fold buffer.toggle_fold(buffer)\nSwitches a header line between expanded and contracted.\n
undo buffer.undo(buffer)\nUndoes one action in the undo history.\n
upper_case buffer.upper_case(buffer)\nTransforms the selection to upper case.\n
use_pop_up buffer.use_pop_up(buffer, allow_popup)\nSets whether a pop up menu is displayed automatically when the user presses\nthe right mouse button.\n
user_list_show buffer.user_list_show(buffer, list_type, item_list_string)\nDisplays a list of strings and sends a notification when one is chosen.\n
vc_home buffer.vc_home(buffer)\nMoves the caret to before the first visible character on the current line\nor the first character on the line if already there.\n
vc_home_extend buffer.vc_home_extend(buffer)\nMoves the caret to before the first visible character on the current line\nor the first character on the line if already there, extending the selection.\n
vc_home_rect_extend buffer.vc_home_rect_extend(buffer)\nMoves the caret to before the first visible character on the current line or\nthe first character on the line if already there, extending the rectangular\nselection.\n
vc_home_wrap buffer.vc_home_wrap(buffer)\nMoves the caret to the first visible character on the current display line\nand then the document line. (If wrap mode is enabled)\n
vc_home_wrap_extend buffer.vc_home_wrap_extend(buffer)\nMoves the caret to the first visible character on the current display line\nand then the document line, extending the selection. (If wrap mode is enabled)\n
vertical_centre_caret buffer.vertical_centre_caret(buffer)\nCenters the caret on the screen.\n
visible_from_doc_line buffer.visible_from_doc_line(buffer, line)\nReturns the display line of a document line taking hidden lines into account.\n
word_end_position buffer.word_end_position(buffer, pos, only_word_chars)\nReturns the position of the end of a word.\n
word_left buffer.word_left(buffer)\nMoves the caret left one word.\n
word_left_end buffer.word_left_end(buffer)\nMoves the caret left one word, positioning the caret at the end of the word.\n
word_left_end_extend buffer.word_left_end_extend(buffer)\nMoves the caret left one word, positioning the caret at the end of the word,\nextending the selection.\n
word_left_extend buffer.word_left_extend(buffer)\nMoves the caret left one word, extending the selection.\n
word_part_left buffer.word_part_left(buffer)\nMoves the caret to the previous change in capitalization or underscore.\n
word_part_left_extend buffer.word_part_left_extend(buffer)\nMoves the caret to the previous change in capitalization or underscore,\nextending the selection.\n
word_part_right buffer.word_part_right(buffer)\nMoves the caret to the next change in capitalization or underscore.\n
word_part_right_extend buffer.word_part_right_extend(buffer)\nMoves the caret to the next change in capitalization or underscore, extending\nthe selection.\n
word_right buffer.word_right(buffer)\nMoves the caret right one word.\n
word_right_end buffer.word_right_end(buffer)\nMoves the caret right one word, positioning the caret at the end of the word.\n
word_right_end_extend buffer.word_right_end_extend(buffer)\nMoves the caret right one word, positioning the caret at the end of the word,\nextending the selection.\n
word_right_extend buffer.word_right_extend(buffer)\nMoves the caret right one word, extending the selection.\n
word_start_position buffer.word_start_position(buffer, pos, only_word_chars)\nReturns the position of a start of a word.\n
wrap_count buffer.wrap_count(buffer, line)\nReturns the number of display lines needed to wrap a document line.\n
zoom_in buffer.zoom_in(buffer)\nMagnifies the displayed text by increasing the font sizes by 1 point.\n
zoom_out buffer.zoom_out(buffer)\nMakes the displayed text smaller by decreasing the font sizes by 1 point.\n
doc_pointer buffer.doc_pointer\nThe pointer to the document associated with this buffer. (Used internally;\nread-only)\n
dirty buffer.dirty\nFlag indicating whether or not the buffer has been modified since it was\nlast saved.\n
filename buffer.filename\nThe absolute path to the file associated with this buffer. It is encoded in\nUTF-8. Use `string.iconv()` for charset conversions.\n
encoding buffer.encoding\nThe encoding of the file on the hard disk. It will be nil if the file is a\nbinary file.\n
encoding_bom buffer.encoding_bom\nThe byte-order mark of the file encoding (if any).\n
additional_caret_fore buffer.additional_caret_fore\nThe foreground color of additional carets.\n
additional_carets_blink buffer.additional_carets_blink\nThe rate in milliseconds at which additional carets blink.\n
additional_carets_visible buffer.additional_carets_visible\nFlag indicating whether or not additional carets are visible.\n
additional_sel_alpha buffer.additional_sel_alpha\nThe alpha of additional selections.\n
additional_sel_back buffer.additional_sel_back\nThe background color of additional selections.\n
additional_sel_fore buffer.additional_sel_fore\nThe foreground color of additional selections.\n
additional_selection_typing buffer.additional_selection_typing\nFlag indicating whether or not typing, backspace, or delete works with\nmultiple selections simultaneously.\n
anchor buffer.anchor\nThe position of the opposite end of the selection to the caret.\n
annotation_lines buffer.annotation_lines\nThe number of lines annotating the indexed line. (Read-only)\n
annotation_style buffer.annotation_style\nThe style of the annotated text at the indexed line.\n
annotation_style_offset buffer.annotation_style_offset\nThe style number offset for annotations. This is used to keep lexer and\nmargin styles separate from annotation styles.\n
annotation_visible buffer.annotation_visible\nThe annotation display mode.\n    * 0: Annotations are not displayed.\n    * 1: Annotations are drawn left justified with no adornment.\n    * 2: Annotations are indented to match the text and are surrounded by a\n         box.\n\n
auto_c_auto_hide buffer.auto_c_auto_hide\nFlag indicating whether or not autocompletion is hidden automatically when\nnothing matches.\n
auto_c_cancel_at_start buffer.auto_c_cancel_at_start\nFlag indicating whether or not autocompletion should be cancelled if the\nuser backspaces to a position before where it was created.\n
auto_c_choose_single buffer.auto_c_choose_single\nFlag indicating whether or not a single item in autocompletion should be\nchosen automatically.\n
auto_c_drop_rest_of_word buffer.auto_c_drop_rest_of_word\nFlag indicating whether or not autocompletion deletes any word characters\nafter the inserted text upon completion.\n
auto_c_fill_ups buffer.auto_c_fill_ups\nA string of characters that when typed will cause the autocompletion to\nchoose the selected item.\n
auto_c_ignore_case buffer.auto_c_ignore_case\nFlag indicating whether or not case is significant when performing\nautocompletion searches.\n
auto_c_max_height buffer.auto_c_max_height\nThe maximum height in rows of autocompletion and user lists. Default is 5.\n
auto_c_max_width buffer.auto_c_max_width\nThe maximum width in characters of autocompletion and user lists.\n
auto_c_separator buffer.auto_c_separator\nThe (integer) separator character in the string setting up an autocompletion\nlist.\n
auto_c_type_separator buffer.auto_c_type_separator\nThe (integer) type separator character in the string setting up an\nautocompletion list.\n
back_space_un_indents buffer.back_space_un_indents\nFlag indicating whether or not a backspace press when the caret is within\nindentation unindents.\n
buffered_draw buffer.buffered_draw\nFlag indicating whether or not text is drawn into a buffer first or directly\nonto the screen.\n
call_tip_back buffer.call_tip_back\nThe background color for the call tip. (Write-only)\n
call_tip_fore buffer.call_tip_fore\nThe foreground color for the call tip. (Write-only)\n
call_tip_fore_hlt buffer.call_tip_fore_hlt\nThe foreground color for the highlighted part of the call tip.\n
call_tip_use_style buffer.call_tip_use_style\nCall tip tab size in pixels. (Enables `STYLE_CALLTIP`.)\n
caret_fore buffer.caret_fore\nThe foreground color of the caret.\n
caret_line_back buffer.caret_line_back\nThe color of the background of the line containing the caret.\n
caret_line_back_alpha buffer.caret_line_back_alpha\nThe background alpha of the caret line.\n
caret_line_visible buffer.caret_line_visible\nFlag indicating whether or not the background of the line containing the\ncaret is a different color.\n
caret_period buffer.caret_period\nThe time in milliseconds that the caret is on and off. 0 is a steady on.\n
caret_sticky buffer.caret_sticky\nFlag indicating whether or not the caret preferred x position can only be\nchanged by explicit movement commands.\n
caret_style buffer.caret_style\nThe style of the caret to be drawn.\n    * 0: invisible\n    * 1: line\n    * 2: block\n\n
caret_width buffer.caret_width\nThe width of the insert mode caret in pixels.\n
char_at buffer.char_at\nThe character byte at given index position. (Read-only)\n
character_pointer buffer.character_pointer\nThe pointer to the first character in the document. (Read-only)\n
code_page buffer.code_page\nThe code page used to interpret the bytes of the document as characters.\n
column buffer.column\nThe column number of an index position, taking tab width into account.\n
control_char_symbol buffer.control_char_symbol\nThe character used to display control characters. (< 32 uses that control\ncharacter)\n
current_pos buffer.current_pos\nThe position of the caret.\n
cursor buffer.cursor\nThe cursor type.\n    * -1: normal\n    * 4: wait.\n\n
direct_function buffer.direct_function\nThe pointer to a function that processes messages for this\nScintilla. (Read-only)\n
direct_pointer buffer.direct_pointer\nThe pointer value to use as the first function argument when calling the\nfunction returned by direct_function.\n
eol_mode buffer.eol_mode\nThe end of line mode.\n    * 0: `CRLF`\n    * 1: `CR`\n    * 2: `LF`\n\n
edge_colour buffer.edge_colour\nThe color used in edge indication.\n
edge_column buffer.edge_column\nThe column number which text should be kept within.\n
edge_mode buffer.edge_mode\nThe edge highlight mode.\n    * 0: None\n    * 1: Line\n    * 2: Background\n\n
end_at_last_line buffer.end_at_last_line\nFlag indicating whether or not the maximum scroll position has the last line\nat the bottom of the view. Default is true.\n
end_styled buffer.end_styled\nThe position of the last correctly styled character. (Read-only)\n
extra_ascent buffer.extra_ascent\nThe extra space above lines.\n
extra_descent buffer.extra_descent\nThe extra space below lines.\n
first_visible_line buffer.first_visible_line\nThe display line at the top of the display.\n
focus buffer.focus\nThe internal focus flag.\n
fold_expanded buffer.fold_expanded\nFlag indicating whether or not an indexed (header) line has been expanded.\n
fold_level buffer.fold_level\nThe fold level of an indexed line.\n    * 0x400: Base\n    * 0x1000: White\n    * 0x2000: Header\n    * 0x0FFF: Number mask\n\n
fold_parent buffer.fold_parent\nThe parent line of indexed (child) line. (Read-only)\n
font_quality buffer.font_quality\nThe font quality (antialiasing method). (Windows only)\n    * 0: Default\n    * 1: Non-antialiased\n    * 2: Antialiased\n    * 3: LCD Optimized\n\n
h_scroll_bar buffer.h_scroll_bar\nFlag indicating whether or not the horizontal scroll bar is visible.\n
highlight_guide buffer.highlight_guide\nThe highlighted indentation guide column.\n
hotspot_active_underline buffer.hotspot_active_underline\nFlag indicating whether or not active hotspots are underlined.\n
hotspot_single_line buffer.hotspot_single_line\nFlag indicating whether or not hotspots are limited to a single line so\nhotspots on two lines do not merge.\n
indent buffer.indent\nThe indentation size.\n
indentation_guides buffer.indentation_guides\nFlag indicating whether or not indentation guides are visible.\n
indic_alpha buffer.indic_alpha\nThe alpha transparency of an indexed indicator. This value ranges from 0\n(transparent) to 100 (opaque).\n
indic_fore buffer.indic_fore\nThe foreground color of an indexed indicator.\n
indic_style buffer.indic_style\nThe style of an indexed indicator.\n    * 0: Plain\n    * 1: Squiggle\n    * 2: TT\n    * 3: Diagonal\n    * 4: Strike\n    * 5: Hidden\n    * 6: Box\n    * 7: Roundbox.\n\n
indic_under buffer.indic_under\nFlag indicating whether or not an indexed indicator is drawn over text. Default\nis `true`.\n
indicator_current buffer.indicator_current\nThe indicator used for `indicator_fill_range` and `indicator_clear_range`.\n
indicator_value buffer.indicator_value\nThe value used for `indicator_fill_range`.\n
key_words buffer.key_words\nUnused.\n
keys_unicode buffer.keys_unicode\nFlag indicating whether or not to treat character keys as unicode.\n
layout_cache buffer.layout_cache\nThe degree of caching of layout information.\n
length buffer.length\nThe number of characters in the document. (Read-only).\n
lexer buffer.lexer\nThe (integer) lexing language of the document.\n
line_count buffer.line_count\nThe number of lines in the document (>= 1). (Read-only).\n
line_end_position buffer.line_end_position\nThe position after the last visible character on an index line. (Read-only)\n
line_indent_position buffer.line_indent_position\nThe position before the first non-indentation character on an indexed\nline. (Read-only)\n
line_indentation buffer.line_indentation\nThe number of columns an indexed line is indented.\n
line_state buffer.line_state\nExtra styling information of an indexed line.\n
line_visible buffer.line_visible\nFlag indicating whether or not the indexed line is visible. (Read-only)\n
lines_on_screen buffer.lines_on_screen\nThe number of lines completely visible. (Read-only)\n
main_selection buffer.main_selection\nThe main selection.\n
margin_cursor_n buffer.margin_cursor_n\nThe cursor shown when the mouse is inside a margin.\n
margin_left buffer.margin_left\nThe size in pixels of the left margin.\n
margin_mask_n buffer.margin_mask_n\nThe marker mask of an indexed margin.\n
margin_right buffer.margin_right\nThe size in pixels of the right margin.\n
margin_sensitive_n buffer.margin_sensitive_n\nFlag indicating whether or not the indexed margin is sensitive to mouse clicks.\n
margin_style buffer.margin_style\nThe style of the margin text at the indexed line.\n
margin_style_offset buffer.margin_style_offset\nThe style number offset for margin text. This is used to keep lexer and\nannotation styles separate from margin styles.\n
margin_type_n buffer.margin_type_n\nThe type of an indexed margin.\n    * 0: Symbolic\n    * 1: Numeric\n\n
margin_width_n buffer.margin_width_n\nThe width of an indexed margin in pixels.\n
max_line_state buffer.max_line_state\nThe last line number that has a line state. (Read-only).\n
mod_event_mask buffer.mod_event_mask\nMask of modification events sent to the container.\n
modify buffer.modify\nFlag indicating whether or not the document is different from when it was\nlast saved.\n
mouse_down_captures buffer.mouse_down_captures\nFlag indicating whether or not the mouse is captured when its button is\npressed.\n
mouse_dwell_time buffer.mouse_dwell_time\nThe time in milliseconds the mouse must sit still to generate a mouse\ndwell event.\n
multi_paste buffer.multi_paste\nHow to paste text into multiple selections.\n    * 0: Just the main selection.\n    * 1: Each selection.\n\n
multiple_selection buffer.multiple_selection\nFlag indicating whether or not to enable multiple selection.\n
overtype buffer.overtype\nFlag indicating whether or not overtype mode is active.\n
paste_convert_endings buffer.paste_convert_endings\nFlag indicating whether or not line endings are converted when pasting text.\n
position_cache buffer.position_cache\nThe number of entries in the position cache.\n
print_colour_mode buffer.print_colour_mode\nThe print color mode.\n    * 0: Normal\n    * 1: Invert the light value of each style\n    * 2: Force black on white\n    * 3: Force background to be white\n    * 4: Only default background is forced to be white\n\n
print_magnification buffer.print_magnification\nThe print magnification added to the point size.\n
print_wrap_mode buffer.print_wrap_mode\nWrap mode.\n    * 0: None\n    * 1: Word\n\n
property buffer.property\nThe (string) value for a given (string) key index.\n
property_int buffer.property_int\nThe (integer) value for a given (string) key index. (Read-only)\n
read_only buffer.read_only\nFlag indicating whether or not the document is read-only.\n
rectangular_selection_anchor buffer.rectangular_selection_anchor\nThe position of the rectangular selection anchor.\n
rectangular_selection_anchor_virtual_space buffer.rectangular_selection_anchor_virtual_space\nThe amount of virtual space for the rectangular selection anchor.\n
rectangular_selection_caret buffer.rectangular_selection_caret\nThe position of the rectangular selection caret.\n
rectangular_selection_caret_virtual_space buffer.rectangular_selection_caret_virtual_space\nThe amount of virtual space for the rectangular selection caret.\n
rectangular_selection_modifier buffer.rectangular_selection_modifier\nThe key used to indicate that a rectangular selection should be created when\ncombined with a mouse drag.\n    * 2: Control\n    * 4: Alt\n    * 8: Super (Win)\n\n
scroll_width buffer.scroll_width\nThe document width assumed for scrolling.\n
scroll_width_tracking buffer.scroll_width_tracking\nFlag indicating whether or not the maximum width line displayed is used to\nset the scroll width.\n
search_flags buffer.search_flags\nThe search flags used by `search_in_target`.\n
sel_alpha buffer.sel_alpha\nThe alpha of the selection.\n
sel_eol_filled buffer.sel_eol_filled\nFlag indicating whether or not the selection end of line is filled.\n
selection_end buffer.selection_end\nThe position that ends the selection. (current_pos)\n
selection_is_rectangle buffer.selection_is_rectangle\nFlag indicating whether or not the selection is rectangular. (Read-only)\n
selection_mode buffer.selection_mode\nThe mode of the current selection.\n    * 0: Stream\n    * 1: Rectangle\n    * 2: Lines\n\n
selection_n_anchor buffer.selection_n_anchor\nThe position of the anchor for an existing selection.\n
selection_n_anchor_virtual_space buffer.selection_n_anchor_virtual_space\nThe amount of virtual space for the anchor for an existing selection.\n
selection_n_caret buffer.selection_n_caret\nThe position of the caret for an existing selection.\n
selection_n_caret_virtual_space buffer.selection_n_caret_virtual_space\nThe amount of virtual space for the anchor for an existing selection.\n
selection_n_end buffer.selection_n_end\nThe end position of an existing selection.\n
selection_n_start buffer.selection_n_start\nThe start position of an existing selection.\n
selection_start buffer.selection_start\nThe position that starts the selection. (anchor)\n
selections buffer.selections\nThe number of selections currently active. (Read-only)\n
status buffer.status\nerror status. 0: OK.\n
style_at buffer.style_at\nThe style byte at the index position. (Read-only)\n
style_back buffer.style_back\nThe background color of an indexed style.\n
style_bits buffer.style_bits\nThe number of bits in style bytes.\n
style_bits_needed buffer.style_bits_needed\nThe number of bits the current lexer needs for styling. (Read-only)\n
style_bold buffer.style_bold\nFlag indicating whether or not the indexed style is bold.\n
style_case buffer.style_case\nThe case of an indexed style.\n    * 0: Mixed\n    * 1: Upper\n    * 2: Lower\n\n
style_changeable buffer.style_changeable\nFlag indicating whether or not the indexed style is changeable.\n
style_character_set buffer.style_character_set\nThe character set of the font in the indexed style.\n
style_eol_filled buffer.style_eol_filled\nFlag indicating whether or not the indexed style's end of line is filled.\n
style_font buffer.style_font\nThe font of the indexed style.\n
style_fore buffer.style_fore\nThe foreground color of the indexed style.\n
style_hot_spot buffer.style_hot_spot\nFlag indicating whether or not the indexed style is a hotspot.\n
style_italic buffer.style_italic\nFlag indicating whether or not the indexed style is italic.\n
style_size buffer.style_size\nThe font size of the indexed style.\n
style_underline buffer.style_underline\nFlag indicating whether or not the indexed style is underlined.\n
style_visible buffer.style_visible\nFlag indicating whether or not the indexed style is visible.\n
tab_indents buffer.tab_indents\nFlag indicating whether or not a tab press when the caret is within indentation\nindents.\n
tab_width buffer.tab_width\nThe visible size of a tab in multiples of the width of a space character.\n
target_end buffer.target_end\nThe position that ends the target which is used for updating the document\nwithout affecting the scroll position.\n
target_start buffer.target_start\nThe position that starts the target which is used for updating the document\nwithout affecting the scroll position.\n
text_length buffer.text_length\nThe number of characters in the document. (Read-only)\n
two_phase_draw buffer.two_phase_draw\nFlag indicating whether or not drawing is performed in two phases: background\nand then foreground.\n
undo_collection buffer.undo_collection\nFlag indicating whether or not an undo history is being collected.\n
use_palette buffer.use_palette\nFlag indicating whether or not Scintilla uses the env's palette calls to\ndisplay more colors.\n
use_tabs buffer.use_tabs\nFlag indicating whether or not indentation uses tabs and spaces or just spaces.\n
v_scroll_bar buffer.v_scroll_bar\nFlag indicating whether or not the vertical scroll bar is visible.\n
view_eol buffer.view_eol\nFlag indicating whether or not end of line characters are visible.\n
view_ws buffer.view_ws\nFlag indicating whether or not whitespace characters are visible.\n
virtual_space_options buffer.virtual_space_options\nOptions for enabling virtual space.\n    * 0: Disabled.\n    * 1: Enabled only for rectangular selection.\n    * 2: Enabled.\n\n
whitespace_chars buffer.whitespace_chars\nThe set of characters making up whitespace when moving or selecting by\nword. Should be called after setting word_chars. (Write-only)\n
wrap_indent_mode buffer.wrap_indent_mode\nThe modes of wrapped sublines.\n    * 0: Wrapped sublines aligned to left of window plus amount set by\n      `buffer.wrap_start_indent`.\n    * 1: Wrapped sublines are aligned to first subline indent.\n    * 2: Wrapped sublines are aligned to first subline indent plus one more\n      level of indentation.\n\n
whitespace_size buffer.whitespace_size\nThe size of the dots used for marking space characters.\n
word_chars buffer.word_chars\nThe set of characters making up words when moving or selecting by\nword. (Write-only)\n
wrap_mode buffer.wrap_mode\nFlag indicating whether or not text is word wrapped.\n
wrap_start_indent buffer.wrap_start_indent\nThe start indent for wrapped lines.\n
wrap_visual_flags buffer.wrap_visual_flags\nThe display mode of visual flags for wrapped lines.\n    * 0: None\n    * 1: End\n    * 2: Start\n\n
wrap_visual_flags_location buffer.wrap_visual_flags_location\nThe location of visual flags for wrapped lines.\n    * 0: Default\n    * 1: End by text\n    * 2: Start by text\n\n
x_offset buffer.x_offset\nThe horizontal scroll position.\n
zoom buffer.zoom\nThe zoom level added to all font sizes. +: magnify, -: reduce.\n
connect events.connect(event, f, index)\nAdds a handler function to an event.\n@param The string event name. It is arbitrary and need not be defined anywhere.\n@param The Lua function to add.\n@param Optional index to insert the handler into.\n@return Index of handler.\n@see disconnect\n
disconnect events.disconnect(event, index)\nDisconnects a handler function from an event.\n@param The string event name.\n@param Index of the handler (returned by events.connect).\n@see connect\n
emit events.emit(event, ...)\nCalls all handlers for the given event in sequence (effectively "generating"\nthe event). If true or false is explicitly returned by any handler, the\nevent is not propagated any further; iteration ceases.\n@param The string event name.\n@param Arguments passed to the handler.\n@return true or false if any handler explicitly returned such; nil otherwise.\n
notification events.notification(n)\nHandles Scintilla notifications.\n@param The Scintilla notification structure as a Lua table.\n@return true or false if any handler explicitly returned such; nil otherwise.\n
_print gui._print(buffer_type, ...)\nHelper function for printing messages to buffers. Splits the view and opens a\nnew buffer for printing messages. If the message buffer is already open and a\nview is currently showing it, the message is printed to that view. Otherwise\nthe view is split, goes to the open message buffer, and prints to it.\n@param String type of message buffer.\n@param Message strings.\n@usage gui._print(L('[Error Buffer]'), error_message)\n@usage gui._print(L('[Message Buffer]'), message)\n
check_focused_buffer gui.check_focused_buffer(buffer)\nChecks if the buffer being indexed is the currently focused buffer. This is\nnecessary because any buffer actions are performed in the focused views'\nbuffer, which may not be the buffer being indexed. Throws an error if the\ncheck fails.\n@param The buffer in question.\n
dialog gui.dialog(kind, ...)\nDisplays a CocoaDialog of a specified type with the given string\narguments. Each argument is like a string in Lua's 'arg' table. Tables of\nstrings are allowed as arguments and are expanded in place. This is useful\nfor filteredlist dialogs with many items.\n@return string CocoaDialog result.\n
filteredlist gui.filteredlist(title, columns, items, int_return, ...)\nShortcut function for gui.dialog('filtered_list', ...) with 'Ok' and 'Cancel'\nbuttons.\n@param The title for the filteredlist dialog.\n@param A column name or list of column names.\n@param An item or list of items.\n@param If true, returns the integer index of the selected item in the\nfilteredlist. Defaults to false, which returns the string item. Not compatible\nwith a '--select-multiple' filteredlist.\n@param Additional parameters to pass to gui.dialog().\n@usage gui.filteredlist('Title', 'Foo', { 'Bar', 'Baz' })\n@usage gui.filteredlist('Title', { 'Foo', 'Bar' }, { 'a', 'b', 'c', 'd' },\nfalse, '--output-column', '2')\n@return Either a string or integer on success; nil otherwise.\n
get_split_table gui.get_split_table()\nGets the current split view structure.\n@return table of split views. Each split view entry is a table with 4 fields:\n1, 2, vertical, and size. 1 and 2 have values of either split view entries\nor the index of the buffer shown in each view. vertical is a flag indicating\nif the split is vertical or not, and size is the integer position of the\nsplit resizer.\n
goto_view gui.goto_view(n, absolute)\nGoes to the specified view. Activates the 'view_*_switch' signal.\n@param A relative or absolute view index.\n@param Flag indicating if n is an absolute index or not.\n
gtkmenu gui.gtkmenu(menu_table)\nCreates a GTK menu, returning the userdata.\n@param A table defining the menu. It is an ordered list of tables with a string\nmenu item and integer menu ID. The string menu item is handled as follows:\n'gtk-*' - a stock menu item is created based on the GTK stock-id. 'separator'\n- a menu separator item is created. Otherwise a regular menu item with a\nmnemonic is created. Submenus are just nested menu-structure tables. Their\ntitle text is defined with a 'title' key.\n
print gui.print(...)\nPrints messages to the Textadept message buffer. Opens a new buffer (if one\nhasn't already been opened) for printing messages.\n@param Message strings.\n
switch_buffer gui.switch_buffer()\nDisplays a dialog with a list of buffers to switch to and switches to the\nselected one, if any.\n
title gui.title\nThe title of the Textadept window.\n
focused_doc_pointer gui.focused_doc_pointer\nThe pointer to the document associated with the buffer of the currently\nfocused view. (Used internally; read-only.)\n
menubar gui.menubar\nA table of GTK menus defining a menubar (write-only).\n
context_menu gui.context_menu\nA GTK menu defining the editor's context menu.\n
clipboard_text gui.clipboard_text\nThe text on the clipboard (read-only).\n
statusbar_text gui.statusbar_text\nThe text displayed by the statusbar.\n
docstatusbar_text gui.docstatusbar_text\nThe text displayed by the doc statusbar (write-only).\n
size gui.size\nThe size of the Textadept window (`{ width, height}`).\n
focus gui.command_entry.focus()\nFocuses the command entry.\n
entry_text gui.command_entry.entry_text\nThe text in the entry.\n
find_in_files gui.find.find_in_files(utf8_dir)\nPerforms a find in files with the given directory. Use the gui.find fields\nto set the text to find and find options.\n@param UTF-8 encoded directory name. If none is provided, the user is prompted\nfor one.\n
find_incremental gui.find.find_incremental()\nBegins an incremental find using the Lua command entry. Lua command\nfunctionality will be unavailable until the search is finished (pressing\n'Escape' by default).\n
find_next gui.find.find_next()\nMimicks a press of the 'Find Next' button in the Find box.\n
find_prev gui.find.find_prev()\nMimicks a press of the 'Find Prev' button in the Find box.\n
focus gui.find.focus()\nDisplays and focuses the find/replace dialog.\n
goto_file_in_list gui.find.goto_file_in_list(next)\nGoes to the next or previous file found relative to the file on the current\nline.\n@param Flag indicating whether or not to go to the next file.\n
replace gui.find.replace()\nMimicks a press of the 'Replace' button in the Find box.\n
replace_all gui.find.replace_all()\nMimicks a press of the 'Replace All' button in the Find box.\n
find_entry_text gui.find.find_entry_text\nThe text in the find entry.\n
replace_entry_text gui.find.replace_entry_text\nThe text in the replace entry.\n
match_case gui.find.match_case\nFlag indicating whether or not case-sensitive search is performed.\n
whole_word gui.find.whole_word\nFlag indicating whether or not only whole-word matches are allowed in searches.\n
lua gui.find.lua\nFlag indicating whether or not the text to find in a search is a Lua pattern.\n
in_files gui.find.in_files\nFlag indicating whether or not to search for the text in a list of files.\n
close_all io.close_all()\nCloses all open buffers. If any buffer is dirty, the user is prompted to\ncontinue. No buffers are saved automatically. They must be saved manually.\n@usage io.close_all()\n@return true if user did not cancel.\n
open_file io.open_file(utf8_filenames)\nOpens a list of files.\n@param A '\\n' separated list of UTF-8-encoded filenames to open. If nil,\nthe user is prompted with a fileselect dialog.\n@usage io.open_file(utf8_encoded_filename)\n
save_all io.save_all()\nSaves all dirty buffers to their respective files.\n@usage io.save_all()\n
close io.close([file])\nEquivalent to `file:close()`. Without a `file`, closes the default output file.\n
flush io.flush()\nEquivalent to `file:flush` over the default output file.\n
input io.input([file])\nWhen called with a file name, it opens the named file (in text mode), and\nsets its handle as the default input file. When called with a file handle,\nit simply sets this file handle as the default input file. When called\nwithout parameters, it returns the current default input file. In case of\nerrors this function raises the error, instead of returning an error code.\n
lines io.lines([filename])\nOpens the given file name in read mode and returns an iterator function that,\neach time it is called, returns a new line from the file. Therefore, the\nconstruction for line in io.lines(filename) do *body* end will iterate over\nall lines of the file. When the iterator function detects the end of file,\nit returns nil (to finish the loop) and automatically closes the file. The\ncall `io.lines()` (with no file name) is equivalent to `io.input():lines()`;\nthat is, it iterates over the lines of the default input file. In this case\nit does not close the file when the loop ends.\n
open io.open(filename [, mode])\nThis function opens a file, in the mode specified in the string `mode`. It\nreturns a new file handle, or, in case of errors, nil plus an error\nmessage. The `mode` string can be any of the following: "r": read mode (the\ndefault); "w": write mode; "a": append mode; "r+": update mode, all previous\ndata is preserved; "w+": update mode, all previous data is erased; "a+":\nappend update mode, previous data is preserved, writing is only allowed at\nthe end of file. The `mode` string can also have a '`b`' at the end, which\nis needed in some systems to open the file in binary mode. This string is\nexactly what is used in the standard C function `fopen`.\n
output io.output([file])\nSimilar to `io.input`, but operates over the default output file.\n
popen io.popen(prog [, mode])\nStarts program `prog` in a separated process and returns a file handle that\nyou can use to read data from this program (if `mode` is `"r"`, the default)\nor to write data to this program (if `mode` is `"w"`). This function is\nsystem dependent and is not available on all platforms.\n
read io.read(···)\nEquivalent to `io.input():read`.\n
tmpfile io.tmpfile()\nReturns a handle for a temporary file. This file is opened in update mode\nand it is automatically removed when the program ends.\n
type io.type(obj)\nChecks whether `obj` is a valid file handle. Returns the string `"file"`\nif `obj` is an open file handle, `"closed file"` if `obj` is a closed file\nhandle, or nil if `obj` is not a file handle.\n
write io.write(···)\nEquivalent to `io.output():write`.\n
stderr io.stderr\nStandard error.\n
stdin io.stdin\nStandard in.\n
stdout io.stdout\nStandard out.\n
CTRL keys.CTRL\nThe string representing the Control key.\n
SHIFT keys.SHIFT\nThe string representing the Shift key.\n
ALT keys.ALT\nThe string representing the Alt key (the Apple key on Mac OSX).\n
ADD keys.ADD\nThe string representing used to join together a sequence of Control, Shift,\nor Alt modifier keys.\n
color lexer.color(r, g, b)\nCreates a Scintilla color.\n@param The string red component of the hexadecimal color.\n@param The string green component of the color.\n@param The string blue component of the color.\n@usage local red = color('FF', '00', '00')\n
delimited_range lexer.delimited_range(chars, escape, end_optional, balanced, forbidden)\nCreates an LPeg pattern that matches a range of characters delimitted by a\nspecific character(s). This can be used to match a string, parenthesis, etc.\n@param The character(s) that bound the matched range.\n@param Optional escape character. This parameter may be omitted, nil, or\nthe empty string.\n@param Optional flag indicating whether or not an ending delimiter is\noptional or not. If true, the range begun by the start delimiter matches\nuntil an end delimiter or the end of the input is reached.\n@param Optional flag indicating whether or not a balanced range is matched,\nlike `%b` in Lua's `string.find`. This flag only applies if `chars` consists\nof two different characters (e.g. '()').\n@param Optional string of characters forbidden in a delimited range. Each\ncharacter is part of the set.\n@usage local sq_str_noescapes = delimited_range("'")\n@usage local sq_str_escapes = delimited_range("'", '\\', true)\n@usage local unbalanced_parens = delimited_range('()', '\\', true)\n@usage local balanced_parens = delimited_range('()', '\\', true, true)\n
embed_lexer lexer.embed_lexer(parent, child, start_rule, end_rule)\nEmbeds a child lexer language in a parent one.\n@param The parent lexer.\n@param The child lexer.\n@param The token that signals the beginning of the embedded lexer.\n@param The token that signals the end of the embedded lexer.\n@usage embed_lexer(_M, css, css_start_rule, css_end_rule)\n@usage embed_lexer(html, _M, php_start_rule, php_end_rule)\n@usage embed_lexer(html, ruby, ruby_start_rule, rule_end_rule)\n
fold lexer.fold(text, start_pos, start_line, start_level)\nFolds the given text. Called by LexLPeg.cxx; do not call from Lua. If the\ncurrent lexer has no _fold function, folding by indentation is performed if\nthe 'fold.by.indentation' property is set.\n@param The document text to fold.\n@param The position in the document text starts at.\n@param The line number text starts on.\n@param The fold level text starts on.\n@return Table of fold levels.\n
get_fold_level lexer.get_fold_level(line, line_number)\nReturns the fold level for a given line. This level already has\n`SC_FOLDLEVELBASE` added to it, so you do not need to add it yourself.\n@param The line number to get the fold level of.\n
get_indent_amount lexer.get_indent_amount(line)\nReturns the indent amount of text for a given line.\n@param The line number to get the indent amount of.\n
get_property lexer.get_property(key, default)\nReturns an integer property value for a given key.\n@param The property key.\n@param Optional integer value to return if key is not set.\n
get_style_at lexer.get_style_at(pos)\nReturns the integer style number at a given position.\n@param The position to get the style for.\n
lex lexer.lex(text, init_style)\nLexes the given text. Called by LexLPeg.cxx; do not call from Lua. If the lexer\nhas a _LEXBYLINE flag set, the text is lexed one line at a time. Otherwise\nthe text is lexed as a whole.\n@param The text to lex.\n@param The current style. Multilang lexers use this to determine which\nlanguage to start lexing in.\n
load lexer.load(lexer_name)\nInitializes the specified lexer.\n@param The name of the lexing language.\n
nested_pair lexer.nested_pair(start_chars, end_chars, end_optional)\nSimilar to `delimited_range()`, but allows for multi-character\ndelimitters. This is useful for lexers with tokens such as nested block\ncomments. With single-character delimiters, this function is identical to\n`delimited_range(start_chars..end_chars, nil, end_optional, true)`.\n@param The string starting a nested sequence.\n@param The string ending a nested sequence.\n@param Optional flag indicating whether or not an ending delimiter is\noptional or not. If true, the range begun by the start delimiter matches\nuntil an end delimiter or the end of the input is reached.\n@usage local nested_comment = l.nested_pair('/*', '*/', true)\n
starts_line lexer.starts_line(patt)\nCreates an LPeg pattern from a given pattern that matches the beginning of\na line and returns it.\n@param The LPeg pattern to match at the beginning of a line.\n@usage local preproc = token(l.PREPROCESSOR, #P('#') * l.starts_line('#'\n* l.nonnewline^0))\n
style lexer.style(style_table)\nCreates a Scintilla style from a table of style properties.\n@param A table of style properties. Style properties available: font         =\n[string] size         = [integer] bold         = [boolean] italic       =\n[boolean] underline    = [boolean] fore         = [integer]* back         =\n[integer]* eolfilled    = [boolean] characterset = ? case         = [integer]\nvisible      = [boolean] changeable   = [boolean] hotspot      = [boolean]\n* Use the value returned by `color()`.\n@usage local bold_italic = style { bold = true, italic = true }\n@see color\n
token lexer.token(name, patt)\nCreates an LPeg capture table index with the name and position of the token.\n@param The name of token. If this name is not in `l.tokens` then you will\nhave to specify a style for it in `lexer._tokenstyles`.\n@param The LPeg pattern associated with the token.\n@usage local ws = token(l.WHITESPACE, l.space^1)\n@usage php_start_rule = token('php_tag', '<?' * ('php' * l.space)^-1)\n
word_match lexer.word_match(words, word_chars, case_insensitive)\nCreates an LPeg pattern that matches a set of words.\n@param A table of words.\n@param Optional string of additional characters considered to be part of a\nword (default is `%w_`).\n@param Optional boolean flag indicating whether the word match is\ncase-insensitive.\n@usage local keyword = token(l.KEYWORD, word_match { 'foo', 'bar', 'baz' })\n@usage local keyword = token(l.KEYWORD, word_match({ 'foo-bar', 'foo-baz',\n'bar-foo', 'bar-baz', 'baz-foo', 'baz-bar' }, '-', true))\n
DEFAULT lexer.DEFAULT\n\n
WHITESPACE lexer.WHITESPACE\n\n
COMMENT lexer.COMMENT\n\n
STRING lexer.STRING\n\n
NUMBER lexer.NUMBER\n\n
KEYWORD lexer.KEYWORD\n\n
IDENTIFIER lexer.IDENTIFIER\n\n
OPERATOR lexer.OPERATOR\n\n
ERROR lexer.ERROR\n\n
PREPROCESSOR lexer.PREPROCESSOR\n\n
CONSTANT lexer.CONSTANT\n\n
VARIABLE lexer.VARIABLE\n\n
FUNCTION lexer.FUNCTION\n\n
CLASS lexer.CLASS\n\n
TYPE lexer.TYPE\n\n
any lexer.any\nMatches any single character.\n
ascii lexer.ascii\nMatches any ASCII character (`0`..`127`).\n
extend lexer.extend\nMatches any ASCII extended character (`0`..`255`).\n
alpha lexer.alpha\nMatches any alphabetic character (`A-Z`, `a-z`).\n
digit lexer.digit\nMatches any digit (`0-9`).\n
alnum lexer.alnum\nMatches any alphanumeric character (`A-Z`, `a-z`, `0-9`).\n
lower lexer.lower\nMatches any lowercase character (`a-z`).\n
upper lexer.upper\nMatches any uppercase character (`A-Z`).\n
xdigit lexer.xdigit\nMatches any hexadecimal digit (`0-9`, `A-F`, `a-f`).\n
cntrl lexer.cntrl\nMatches any control character (`0`..`31`).\n
graph lexer.graph\nMatches any graphical character (`!` to `~`).\n
print lexer.print\nMatches any printable character (space to `~`).\n
punct lexer.punct\nMatches any punctuation character not alphanumeric (`!` to `/`, `:` to `@`,\n`[` to `'`, `{` to `~`).\n
space lexer.space\nMatches any whitespace character (`\t`, `\v`, `\f`, `\\n`, `\r`, space).\n
newline lexer.newline\nMatches any newline characters.\n
nonnewline lexer.nonnewline\nMatches any non-newline character.\n
nonnewline_esc lexer.nonnewline_esc\nMatches any non-newline character excluding newlines escaped with `\\`.\n
dec_num lexer.dec_num\nMatches a decimal number.\n
hex_num lexer.hex_num\nMatches a hexadecimal number.\n
oct_num lexer.oct_num\nMatches an octal number.\n
integer lexer.integer\nMatches a decimal, hexadecimal, or octal number.\n
float lexer.float\nMatches a floating point number.\n
word lexer.word\nMatches a typical word starting with a letter or underscore and then any\nalphanumeric or underscore characters.\n
style_nothing lexer.style_nothing\nTypically used for whitespace.\n
style_char lexer.style_char\nTypically used for character literals.\n
style_class lexer.style_class\nTypically used for class definitions.\n
style_comment lexer.style_comment\nTypically used for code comments.\n
style_constant lexer.style_constant\nTypically used for constants.\n
style_definition lexer.style_definition\nTypically used for definitions.\n
style_error lexer.style_error\nTypically used for erroneous syntax.\n
style_function lexer.style_function\nTypically used for function definitions.\n
style_keyword lexer.style_keyword\nTypically used for language keywords.\n
style_number lexer.style_number\nTypically used for numbers.\n
style_operator lexer.style_operator\nTypically used for operators.\n
style_string lexer.style_string\nTypically used for strings.\n
style_preproc lexer.style_preproc\nTypically used for preprocessor statements.\n
style_tag lexer.style_tag\nTypically used for markup tags.\n
style_type lexer.style_type\nTypically used for static types.\n
style_variable lexer.style_variable\nTypically used for variables.\n
style_embedded lexer.style_embedded\nTypically used for embedded code.\n
style_identifier lexer.style_identifier\nTypically used for identifier words.\n
green lexer.green\n\n
blue lexer.blue\n\n
red lexer.red\n\n
yellow lexer.yellow\n\n
teal lexer.teal\n\n
white lexer.white\n\n
black lexer.black\n\n
grey lexer.grey\n\n
purple lexer.purple\n\n
orange lexer.orange\n\n
SC_FOLDLEVELBASE lexer.SC_FOLDLEVELBASE\nThe initial (root) fold level.\n
SC_FOLDLEVELWHITEFLAG lexer.SC_FOLDLEVELWHITEFLAG\nFlag indicating that the line is blank.\n
SC_FOLDLEVELHEADERFLAG lexer.SC_FOLDLEVELHEADERFLAG\nFlag indicating the line is fold point.\n
SC_FOLDLEVELNUMBERMASK lexer.SC_FOLDLEVELNUMBERMASK\nFlag used with `SCI_GETFOLDLEVEL(line)` to get the fold level of a line.\n
localize locale.localize(id)\nLocalizes the given string.\n@param String to localize.\n
iconv string.iconv(text, to, from)\nConverts a string from one character set to another using iconv(). Valid\ncharacter sets are ones GLib's g_convert() accepts, typically GNU iconv's\ncharacter sets.\n@param The text to convert.\n@param The character set to convert to.\n@param The character set to convert from.\n
byte string.byte(s [, i [, j]])\nReturns the internal numerical codes of the characters `s[i]`, `s[i+1]`,\n···, `s[j]`. The default value for `i` is 1; the default value for `j` is\n`i`. Note that numerical codes are not necessarily portable across platforms.\n
char string.char(···)\nReceives zero or more integers. Returns a string with length equal to the\nnumber of arguments, in which each character has the internal numerical\ncode equal to its corresponding argument. Note that numerical codes are not\nnecessarily portable across platforms.\n
dump string.dump(function)\nReturns a string containing a binary representation of the given function,\nso that a later `loadstring` on this string returns a copy of the\nfunction. `function` must be a Lua function without upvalues.\n
find string.find(s, pattern [, init [, plain]])\nLooks for the first match of `pattern` in the string `s`. If it finds a\nmatch, then `find` returns the indices of `s` where this occurrence starts\nand ends; otherwise, it returns nil. A third, optional numerical argument\n`init` specifies where to start the search; its default value is 1 and can\nbe negative. A value of true as a fourth, optional argument `plain` turns off\nthe pattern matching facilities, so the function does a plain "find substring"\noperation, with no characters in `pattern` being considered "magic". Note that\nif `plain` is given, then `init` must be given as well. If the pattern has\ncaptures, then in a successful match the captured values are also returned,\nafter the two indices.\n
format string.format(formatstring, ···)\nReturns a formatted version of its variable number of arguments following\nthe description given in its first argument (which must be a string). The\nformat string follows the same rules as the `printf` family of standard C\nfunctions. The only differences are that the options/modifiers `*`, `l`,\n`L`, `n`, `p`, and `h` are not supported and that there is an extra option,\n`q`. The `q` option formats a string in a form suitable to be safely read back\nby the Lua interpreter: the string is written between double quotes, and all\ndouble quotes, newlines, embedded zeros, and backslashes in the string are\ncorrectly escaped when written. For instance, the call string.format('%q',\n'a string with "quotes" and \\n new line') will produce the string: "a string\nwith \"quotes\" and \ new line" The options `c`, `d`, `E`, `e`, `f`, `g`,\n`G`, `i`, `o`, `u`, `X`, and `x` all expect a number as argument, whereas\n`q` and `s` expect a string. This function does not accept string values\ncontaining embedded zeros, except as arguments to the `q` option.\n
gmatch string.gmatch(s, pattern)\nReturns an iterator function that, each time it is called, returns the\nnext captures from `pattern` over string `s`. If `pattern` specifies no\ncaptures, then the whole match is produced in each call. As an example,\nthe following loop s = "hello world from Lua" for w in string.gmatch(s,\n"%a+") do print(w) end will iterate over all the words from string `s`,\nprinting one per line. The next example collects all pairs `key=value`\nfrom the given string into a table: t = {} s = "from=world, to=Lua" for k,\nv in string.gmatch(s, "(%w+)=(%w+)") do t[k] = v end For this function, a\n'`^`' at the start of a pattern does not work as an anchor, as this would\nprevent the iteration.\n
gsub string.gsub(s, pattern, repl [, n])\nReturns a copy of `s` in which all (or the first `n`, if given) occurrences\nof the `pattern` have been replaced by a replacement string specified by\n`repl`, which can be a string, a table, or a function. `gsub` also returns,\nas its second value, the total number of matches that occurred. If `repl`\nis a string, then its value is used for replacement. The character `%`\nworks as an escape character: any sequence in `repl` of the form `%n`, with\n*n* between 1 and 9, stands for the value of the *n*-th captured substring\n(see below). The sequence `%0` stands for the whole match. The sequence `%%`\nstands for a single `%`. If `repl` is a table, then the table is queried for\nevery match, using the first capture as the key; if the pattern specifies no\ncaptures, then the whole match is used as the key. If `repl` is a function,\nthen this function is called every time a match occurs, with all captured\nsubstrings passed as arguments, in order; if the pattern specifies no\ncaptures, then the whole match is passed as a sole argument. If the value\nreturned by the table query or by the function call is a string or a number,\nthen it is used as the replacement string; otherwise, if it is false or nil,\nthen there is no replacement (that is, the original match is kept in the\nstring). Here are some examples: x = string.gsub("hello world", "(%w+)",\n"%1 %1") --> x="hello hello world world" x = string.gsub("hello world", "%w+",\n"%0 %0", 1) --> x="hello hello world" x = string.gsub("hello world from Lua",\n"(%w+)%s*(%w+)", "%2 %1") --> x="world hello Lua from" x = string.gsub("home =\n$HOME, user = $USER", "%$(%w+)", os.getenv) --> x="home = /home/roberto, user =\nroberto" x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s) return\nloadstring(s)() end) --> x="4+5 = 9" local t = {name="lua", version="5.1"}\nx = string.gsub("$name-$version.tar.gz", "%$(%w+)", t) --> x="lua-5.1.tar.gz"\n
len string.len(s)\nReceives a string and returns its length. The empty string `""` has length\n0. Embedded zeros are counted, so `"a\000bc\000"` has length 5.\n
lower string.lower(s)\nReceives a string and returns a copy of this string with all uppercase\nletters changed to lowercase. All other characters are left unchanged. The\ndefinition of what an uppercase letter is depends on the current locale.\n
match string.match(s, pattern [, init])\nLooks for the first *match* of `pattern` in the string `s`. If it finds one,\nthen `match` returns the captures from the pattern; otherwise it returns\nnil. If `pattern` specifies no captures, then the whole match is returned. A\nthird, optional numerical argument `init` specifies where to start the search;\nits default value is 1 and can be negative.\n
rep string.rep(s, n)\nReturns a string that is the concatenation of `n` copies of the string `s`.\n
reverse string.reverse(s)\nReturns a string that is the string `s` reversed.\n
sub string.sub(s, i [, j])\nReturns the substring of `s` that starts at `i` and continues until `j`;\n`i` and `j` can be negative. If `j` is absent, then it is assumed to\nbe equal to -1 (which is the same as the string length). In particular,\nthe call `string.sub(s,1,j)` returns a prefix of `s` with length `j`, and\n`string.sub(s, -i)` returns a suffix of `s` with length `i`.\n
upper string.upper(s)\nReceives a string and returns a copy of this string with all lowercase\nletters changed to uppercase. All other characters are left unchanged. The\ndefinition of what a lowercase letter is depends on the current locale.\n
focus view:focus()\nFocuses the indexed view if it hasn't been already.\n
goto_buffer view:goto_buffer(n, absolute)\nGoes to the specified buffer in the indexed view. Activates the\n'buffer_*_switch' signals.\n@param A relative or absolute buffer index.\n@param Flag indicating if n is an absolute index or not.\n
split view:split(vertical)\nSplits the indexed view vertically or horizontally and focuses the new view.\n@param Flag indicating a vertical split. False for horizontal.\n@return old view and new view tables.\n
unsplit view:unsplit()\nUnsplits the indexed view if possible.\n@return boolean if the view was unsplit or not.\n
doc_pointer view.doc_pointer\nThe pointer to the document associated with this view's buffer. (Used\ninternally; read-only)\n
size view.size\nThe integer position of the split resizer (if this view is part of a split\nview).\n
create coroutine.create(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua function. Returns\nthis new coroutine, an object with type `"thread"`.\n
resume coroutine.resume(co [, val1, ···])\nStarts or continues the execution of coroutine `co`. The first time you resume\na coroutine, it starts running its body. The values `val1`, ··· are passed\nas the arguments to the body function. If the coroutine has yielded, `resume`\nrestarts it; the values `val1`, ··· are passed as the results from the\nyield. If the coroutine runs without any errors, `resume` returns true plus\nany values passed to `yield` (if the coroutine yields) or any values returned\nby the body function (if the coroutine terminates). If there is any error,\n`resume` returns false plus the error message.\n
running coroutine.running()\nReturns the running coroutine, or nil when called by the main thread.\n
status coroutine.status(co)\nReturns the status of coroutine `co`, as a string: `"running"`, if the\ncoroutine is running (that is, it called `status`); `"suspended"`, if the\ncoroutine is suspended in a call to `yield`, or if it has not started running\nyet; `"normal"` if the coroutine is active but not running (that is, it has\nresumed another coroutine); and `"dead"` if the coroutine has finished its\nbody function, or if it has stopped with an error.\n
wrap coroutine.wrap(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua function. Returns\na function that resumes the coroutine each time it is called. Any arguments\npassed to the function behave as the extra arguments to `resume`. Returns\nthe same values returned by `resume`, except the first boolean. In case of\nerror, propagates the error.\n
yield coroutine.yield(···)\nSuspends the execution of the calling coroutine. The coroutine cannot be\nrunning a C function, a metamethod, or an iterator. Any arguments to `yield`\nare passed as extra results to `resume`.\n
debug debug.debug()\nEnters an interactive mode with the user, running each string that the user\nenters. Using simple commands and other debug facilities, the user can inspect\nglobal and local variables, change their values, evaluate expressions, and so\non. A line containing only the word `cont` finishes this function, so that\nthe caller continues its execution. Note that commands for `debug.debug`\nare not lexically nested within any function, and so have no direct access\nto local variables.\n
getfenv debug.getfenv(o)\nReturns the environment of object `o`.\n
gethook debug.gethook([thread])\nReturns the current hook settings of the thread, as three values: the current\nhook function, the current hook mask, and the current hook count (as set by\nthe `debug.sethook` function).\n
getinfo debug.getinfo([thread, ] function [, what])\nReturns a table with information about a function. You can give the function\ndirectly, or you can give a number as the value of `function`, which means\nthe function running at level `function` of the call stack of the given\nthread: level 0 is the current function (`getinfo` itself); level 1 is the\nfunction that called `getinfo`; and so on. If `function` is a number larger\nthan the number of active functions, then `getinfo` returns nil. The returned\ntable can contain all the fields returned by `lua_getinfo`, with the string\n`what` describing which fields to fill in. The default for `what` is to get\nall information available, except the table of valid lines. If present,\nthe option '`f`' adds a field named `func` with the function itself. If\npresent, the option '`L`' adds a field named `activelines` with the table\nof valid lines. For instance, the expression `debug.getinfo(1,"n").name`\nreturns a table with a name for the current function, if a reasonable name\ncan be found, and the expression `debug.getinfo(print)` returns a table with\nall available information about the `print` function.\n
getlocal debug.getlocal([thread, ] level, local)\nThis function returns the name and the value of the local variable with index\n`local` of the function at level `level` of the stack. (The first parameter\nor local variable has index 1, and so on, until the last active local\nvariable.) The function returns nil if there is no local variable with the\ngiven index, and raises an error when called with a `level` out of range. (You\ncan call `debug.getinfo` to check whether the level is valid.) Variable\nnames starting with '`(`' (open parentheses) represent internal variables\n(loop control variables, temporaries, and C function locals).\n
getmetatable debug.getmetatable(object)\nReturns the metatable of the given `object` or nil if it does not have\na metatable.\n
getregistry debug.getregistry()\nReturns the registry table (see §3.5).\n
getupvalue debug.getupvalue(func, up)\nThis function returns the name and the value of the upvalue with index `up`\nof the function `func`. The function returns nil if there is no upvalue with\nthe given index.\n
setfenv debug.setfenv(object, table)\nSets the environment of the given `object` to the given `table`. Returns\n`object`.\n
sethook debug.sethook([thread, ] hook, mask [, count])\nSets the given function as a hook. The string `mask` and the number `count`\ndescribe when the hook will be called. The string mask may have the following\ncharacters, with the given meaning: `"c"`: the hook is called every time\nLua calls a function; `"r"`: the hook is called every time Lua returns from\na function; `"l"`: the hook is called every time Lua enters a new line of\ncode. With a `count` different from zero, the hook is called after every\n`count` instructions. When called without arguments, `debug.sethook` turns\noff the hook. When the hook is called, its first parameter is a string\ndescribing the event that has triggered its call: `"call"`, `"return"`\n(or `"tail return"`, when simulating a return from a tail call), `"line"`,\nand `"count"`. For line events, the hook also gets the new line number as\nits second parameter. Inside a hook, you can call `getinfo` with level 2 to\nget more information about the running function (level 0 is the `getinfo`\nfunction, and level 1 is the hook function), unless the event is `"tail\nreturn"`. In this case, Lua is only simulating the return, and a call to\n`getinfo` will return invalid data.\n
setlocal debug.setlocal([thread, ] level, local, value)\nThis function assigns the value `value` to the local variable with index\n`local` of the function at level `level` of the stack. The function returns nil\nif there is no local variable with the given index, and raises an error when\ncalled with a `level` out of range. (You can call `getinfo` to check whether\nthe level is valid.) Otherwise, it returns the name of the local variable.\n
setmetatable debug.setmetatable(object, table)\nSets the metatable for the given `object` to the given `table` (which can\nbe nil).\n
setupvalue debug.setupvalue(func, up, value)\nThis function assigns the value `value` to the upvalue with index `up` of\nthe function `func`. The function returns nil if there is no upvalue with\nthe given index. Otherwise, it returns the name of the upvalue.\n
attributes lfs.attributes(filepath [, aname])\nReturns a table with the file attributes corresponding to filepath (or\nnil followed by an error message in case of error). If the second optional\nargument is given, then only the value of the named attribute is returned\n(this use is equivalent to lfs.attributes(filepath).aname, but the table is not\ncreated and only one attribute is retrieved from the O.S.). The attributes are\ndescribed as follows; attribute mode is a string, all the others are numbers,\nand the time related attributes use the same time reference of os.time: dev:\non Unix systems, this represents the device that the inode resides on. On\nWindows systems, represents the drive number of the disk containing the file\nino: on Unix systems, this represents the inode number. On Windows systems\nthis has no meaning mode: string representing the associated protection mode\n(the values could be file, directory, link, socket, named pipe, char device,\nblock device or other) nlink: number of hard links to the file uid: user-id\nof owner (Unix only, always 0 on Windows) gid: group-id of owner (Unix only,\nalways 0 on Windows) rdev: on Unix systems, represents the device type, for\nspecial file inodes. On Windows systems represents the same as dev access:\ntime of last access modification: time of last data modification change:\ntime of last file status change size: file size, in bytes blocks: block\nallocated for file; (Unix only) blksize: optimal file system I/O blocksize;\n(Unix only) This function uses stat internally thus if the given filepath is\na symbolic link, it is followed (if it points to another link the chain is\nfollowed recursively) and the information is about the file it refers to. To\nobtain information about the link itself, see function lfs.symlinkattributes.\n
chdir lfs.chdir(path)\nChanges the current working directory to the given path. Returns true in\ncase of success or nil plus an error string.\n
currentdir lfs.currentdir()\nReturns a string with the current working directory or nil plus an error\nstring.\n
dir lfs.dir(path)\nLua iterator over the entries of a given directory. Each time the iterator\nis called with dir_obj it returns a directory entry's name as a string,\nor nil if there are no more entries. You can also iterate by calling\ndir_obj:next(), and explicitly close the directory before the iteration\nfinished with dir_obj:close(). Raises an error if path is not a directory.\n
lock lfs.lock(filehandle, mode[, start[, length]])\nLocks a file or a part of it. This function works on open files; the file\nhandle should be specified as the first argument. The string mode could be\neither r (for a read/shared lock) or w (for a write/exclusive lock). The\noptional arguments start and length can be used to specify a starting point\nand its length; both should be numbers. Returns true if the operation was\nsuccessful; in case of error, it returns nil plus an error string.\n
lock_dir lfs.lock_dir(path, [seconds_stale])\nCreates a lockfile (called lockfile.lfs) in path if it does not exist and\nreturns the lock. If the lock already exists checks it it's stale, using\nthe second parameter (default for the second parameter is INT_MAX, which\nin practice means the lock will never be stale. To free the the lock call\nlock:free(). In case of any errors it returns nil and the error message. In\nparticular, if the lock exists and is not stale it returns the "File exists"\nmessage.\n
mkdir lfs.mkdir(dirname)\nCreates a new directory. The argument is the name of the new directory. Returns\ntrue if the operation was successful; in case of error, it returns nil plus\nan error string.\n
rmdir lfs.rmdir(dirname)\nRemoves an existing directory. The argument is the name of the\ndirectory. Returns true if the operation was successful; in case of error,\nit returns nil plus an error string.\n
setmode lfs.setmode(file, mode)\nSets the writing mode for a file. The mode string can be either binary or\ntext. Returns the previous mode string for the file. This function is only\navailable in Windows, so you may want to make sure that lfs.setmode exists\nbefore using it.\n
symlinkattributes lfs.symlinkattributes(filepath [, aname])\nIdentical to lfs.attributes except that it obtains information about the link\nitself (not the file it refers to). This function is not available in Windows\nso you may want to make sure that lfs.symlinkattributes exists before using it.\n
touch lfs.touch(filepath [, atime [, mtime]])\nSet access and modification times of a file. This function is a bind to utime\nfunction. The first argument is the filename, the second argument (atime)\nis the access time, and the third argument (mtime) is the modification\ntime. Both times are provided in seconds (which should be generated with\nLua standard function os.time). If the modification time is omitted, the\naccess time provided is used; if both times are omitted, the current time\nis used. Returns true if the operation was successful; in case of error,\nit returns nil plus an error string.\n
unlock lfs.unlock(filehandle[, start[, length]])\nUnlocks a file or a part of it. This function works on open files; the file\nhandle should be specified as the first argument. The optional arguments\nstart and length can be used to specify a starting point and its length;\nboth should be numbers. Returns true if the operation was successful; in\ncase of error, it returns nil plus an error string.\n
C lpeg.C(patt)\nCreates a simple capture, which captures the substring of the subject that\nmatches patt. The captured value is a string. If patt has other captures,\ntheir values are returned after this one.\n
Carg lpeg.Carg(n)\nCreates an argument capture. This pattern matches the empty string and produces\nthe value given as the nth extra argument given in the call to lpeg.match.\n
Cb lpeg.Cb(name)\nCreates a back capture. This pattern matches the empty string and produces the\nvalues produced by the most recent group capture named name. Most recent means\nthe last complete outermost group capture with the given name. A Complete\ncapture means that the entire pattern corresponding to the capture has\nmatched. An Outermost capture means that the capture is not inside another\ncomplete capture.\n
Cc lpeg.Cc([value, ...])\nCreates a constant capture. This pattern matches the empty string and produces\nall given values as its captured values.\n
Cf lpeg.Cf(patt, func)\nCreates a fold capture. If patt produces a list of captures C1 C2 ... Cn,\nthis capture will produce the value func(...func(func(C1, C2), C3)...,\nCn), that is, it will fold (or accumulate, or reduce) the captures from\npatt using function func. This capture assumes that patt should produce at\nleast one capture with at least one value (of any type), which becomes the\ninitial value of an accumulator. (If you need a specific initial value,\nyou may prefix a constant capture to patt.) For each subsequent capture\nLPeg calls func with this accumulator as the first argument and all values\nproduced by the capture as extra arguments; the value returned by this call\nbecomes the new value for the accumulator. The final value of the accumulator\nbecomes the captured value. As an example, the following pattern matches a\nlist of numbers separated by commas and returns their addition: -- matches\na numeral and captures its value number = lpeg.R"09"^1 / tonumber -- matches\na list of numbers, captures their values list = number * ("," * number)^0 --\nauxiliary function to add two numbers function add (acc, newvalue) return acc\n+ newvalue end -- folds the list of numbers adding them sum = lpeg.Cf(list,\nadd) -- example of use print(sum:match("10,30,43"))   --> 83\n
Cg lpeg.Cg(patt [, name])\nCreates a group capture. It groups all values returned by patt into a single\ncapture. The group may be anonymous (if no name is given) or named with the\ngiven name. An anonymous group serves to join values from several captures into\na single capture. A named group has a different behavior. In most situations,\na named group returns no values at all. Its values are only relevant for a\nfollowing back capture or when used inside a table capture.\n
Cmt lpeg.Cmt(patt, function)\nCreates a match-time capture. Unlike all other captures, this one is evaluated\nimmediately when a match occurs. It forces the immediate evaluation of all its\nnested captures and then calls function. The given function gets as arguments\nthe entire subject, the current position (after the match of patt), plus any\ncapture values produced by patt. The first value returned by function defines\nhow the match happens. If the call returns a number, the match succeeds and\nthe returned number becomes the new current position. (Assuming a subject s\nand current position i, the returned number must be in the range [i, len(s)\n+ 1].) If the call returns true, the match succeeds without consuming any\ninput. (So, to return true is equivalent to return i.) If the call returns\nfalse, nil, or no value, the match fails. Any extra values returned by the\nfunction become the values produced by the capture.\n
Cp lpeg.Cp()\nCreates a position capture. It matches the empty string and captures the\nposition in the subject where the match occurs. The captured value is a number.\n
Cs lpeg.Cs(patt)\nCreates a substitution capture, which captures the substring of the subject\nthat matches patt, with substitutions. For any capture inside patt with\na value, the substring that matched the capture is replaced by the capture\nvalue (which should be a string). The final captured value is the string\nresulting from all replacements.\n
Ct lpeg.Ct(patt)\nCreates a table capture. This capture creates a table and puts all values\nfrom all anonymous captures made by patt inside this table in successive\ninteger keys, starting at 1. Moreover, for each named capture group created\nby patt, the first value of the group is put into the table with the group\nname as its key. The captured value is only the table.\n
P lpeg.P(value)\nConverts the given value into a proper pattern, according to the following\nrules: * If the argument is a pattern, it is returned unmodified. * If the\nargument is a string, it is translated to a pattern that matches literally\nthe string. * If the argument is a non-negative number n, the result is a\npattern that matches exactly n characters. * If the argument is a negative\nnumber -n, the result is a pattern that succeeds only if the input string\ndoes not have n characters: lpeg.P(-n) is equivalent to -lpeg.P(n) (see\nthe unary minus operation). * If the argument is a boolean, the result is\na pattern that always succeeds or always fails (according to the boolean\nvalue), without consuming any input. * If the argument is a table, it is\ninterpreted as a grammar (see Grammars). * If the argument is a function,\nreturns a pattern equivalent to a match-time capture over the empty string.\n
R lpeg.R({range})\nReturns a pattern that matches any single character belonging to one of\nthe given ranges. Each range is a string xy of length 2, representing all\ncharacters with code between the codes of x and y (both inclusive). As an\nexample, the pattern lpeg.R("09") matches any digit, and lpeg.R("az", "AZ")\nmatches any ASCII letter.\n
S lpeg.S(string)\nReturns a pattern that matches any single character that appears in the given\nstring. (The S stands for Set.) As an example, the pattern lpeg.S("+-*/")\nmatches any arithmetic operator. Note that, if s is a character (that is,\na string of length 1), then lpeg.P(s) is equivalent to lpeg.S(s) which is\nequivalent to lpeg.R(s..s). Note also that both lpeg.S("") and lpeg.R()\nare patterns that always fail.\n
V lpeg.V(v)\nThis operation creates a non-terminal (a variable) for a grammar. The created\nnon-terminal refers to the rule indexed by v in the enclosing grammar. (See\nGrammars for details.)\n
locale lpeg.locale([table])\nReturns a table with patterns for matching some character classes according\nto the current locale. The table has fields named alnum, alpha, cntrl, digit,\ngraph, lower, print, punct, space, upper, and xdigit, each one containing a\ncorrespondent pattern. Each pattern matches any single character that belongs\nto its class. If called with an argument table, then it creates those fields\ninside the given table and returns that table.\n
match lpeg.match(pattern, subject [, init])\nThe matching function. It attempts to match the given pattern against the\nsubject string. If the match succeeds, returns the index in the subject of\nthe first character after the match, or the captured values (if the pattern\ncaptured any value). An optional numeric argument init makes the match starts\nat that position in the subject string. As usual in Lua libraries, a negative\nvalue counts from the end. Unlike typical pattern-matching functions, match\nworks only in anchored mode; that is, it tries to match the pattern with a\nprefix of the given subject string (at position init), not with an arbitrary\nsubstring of the subject. So, if we want to find a pattern anywhere in a\nstring, we must either write a loop in Lua or write a pattern that matches\nanywhere. This second approach is easy and quite efficient; see examples.\n
setmaxstack lpeg.setmaxstack(max)\nSets the maximum size for the backtrack stack used by LPeg to track calls\nand choices. Most well-written patterns need little backtrack levels and\ntherefore you seldom need to change this maximum; but a few useful patterns\nmay need more space. Before changing this maximum you should try to rewrite\nyour pattern to avoid the need for extra space.\n
type lpeg.type(value)\nIf the given value is a pattern, returns the string "pattern". Otherwise\nreturns nil.\n
version lpeg.version()\nReturns a string with the running version of LPeg.\n
abs math.abs(x)\nReturns the absolute value of `x`.\n
acos math.acos(x)\nReturns the arc cosine of `x` (in radians).\n
asin math.asin(x)\nReturns the arc sine of `x` (in radians).\n
atan math.atan(x)\nReturns the arc tangent of `x` (in radians).\n
atan2 math.atan2(y, x)\nReturns the arc tangent of `y/x` (in radians), but uses the signs of both\nparameters to find the quadrant of the result. (It also handles correctly\nthe case of `x` being zero.)\n
ceil math.ceil(x)\nReturns the smallest integer larger than or equal to `x`.\n
cos math.cos(x)\nReturns the cosine of `x` (assumed to be in radians).\n
cosh math.cosh(x)\nReturns the hyperbolic cosine of `x`.\n
deg math.deg(x)\nReturns the angle `x` (given in radians) in degrees.\n
exp math.exp(x)\nReturns the value *e^x*.\n
floor math.floor(x)\nReturns the largest integer smaller than or equal to `x`.\n
fmod math.fmod(x, y)\nReturns the remainder of the division of `x` by `y` that rounds the quotient\ntowards zero.\n
frexp math.frexp(x)\nReturns `m` and `e` such that *x = m2^e*, `e` is an integer and the absolute\nvalue of `m` is in the range *[0.5, 1)* (or zero when `x` is zero).\n
ldexp math.ldexp(m, e)\nReturns *m2^e* (`e` should be an integer).\n
log math.log(x)\nReturns the natural logarithm of `x`.\n
log10 math.log10(x)\nReturns the base-10 logarithm of `x`.\n
max math.max(x, ···)\nReturns the maximum value among its arguments.\n
min math.min(x, ···)\nReturns the minimum value among its arguments.\n
modf math.modf(x)\nReturns two numbers, the integral part of `x` and the fractional part of `x`.\n
pow math.pow(x, y)\nReturns *x^y*. (You can also use the expression `x^y` to compute this value.)\n
rad math.rad(x)\nReturns the angle `x` (given in degrees) in radians.\n
random math.random([m [, n]])\nThis function is an interface to the simple pseudo-random generator function\n`rand` provided by ANSI C. (No guarantees can be given for its statistical\nproperties.) When called without arguments, returns a uniform pseudo-random\nreal number in the range *[0,1)*. When called with an integer number `m`,\n`math.random` returns a uniform pseudo-random integer in the range *[1,\nm]*. When called with two integer numbers `m` and `n`, `math.random` returns\na uniform pseudo-random integer in the range *[m, n]*.\n
randomseed math.randomseed(x)\nSets `x` as the "seed" for the pseudo-random generator: equal seeds produce\nequal sequences of numbers.\n
sin math.sin(x)\nReturns the sine of `x` (assumed to be in radians).\n
sinh math.sinh(x)\nReturns the hyperbolic sine of `x`.\n
sqrt math.sqrt(x)\nReturns the square root of `x`. (You can also use the expression `x^0.5`\nto compute this value.)\n
tan math.tan(x)\nReturns the tangent of `x` (assumed to be in radians).\n
tanh math.tanh(x)\nReturns the hyperbolic tangent of `x`.\n
HUGE_VAL math.HUGE_VAL\nThe value `HUGE_VAL`, a value larger than or equal to any other numerical\nvalue.\n
pi math.pi\nThe value of *pi*.\n
clock os.clock()\nReturns an approximation of the amount in seconds of CPU time used by the\nprogram.\n
date os.date([format [, time]])\nReturns a string or a table containing date and time, formatted according to\nthe given string `format`. If the `time` argument is present, this is the\ntime to be formatted (see the `os.time` function for a description of this\nvalue). Otherwise, `date` formats the current time. If `format` starts with\n'`!`', then the date is formatted in Coordinated Universal Time. After\nthis optional character, if `format` is the string "`*t`", then `date`\nreturns a table with the following fields: `year` (four digits), `month`\n(1--12), `day` (1--31), `hour` (0--23), `min` (0--59), `sec` (0--61), `wday`\n(weekday, Sunday is 1), `yday` (day of the year), and `isdst` (daylight\nsaving flag, a boolean). If `format` is not "`*t`", then `date` returns the\ndate as a string, formatted according to the same rules as the C function\n`strftime`. When called without arguments, `date` returns a reasonable date\nand time representation that depends on the host system and on the current\nlocale (that is, `os.date()` is equivalent to `os.date("%c")`).\n
difftime os.difftime(t2, t1)\nReturns the number of seconds from time `t1` to time `t2`. In POSIX, Windows,\nand some other systems, this value is exactly `t2`*-*`t1`.\n
execute os.execute([command])\nThis function is equivalent to the C function `system`. It passes `command`\nto be executed by an operating system shell. It returns a status code,\nwhich is system-dependent. If `command` is absent, then it returns nonzero\nif a shell is available and zero otherwise.\n
exit os.exit([code])\nCalls the C function `exit`, with an optional `code`, to terminate the host\nprogram. The default value for `code` is the success code.\n
getenv os.getenv(varname)\nReturns the value of the process environment variable `varname`, or nil if\nthe variable is not defined.\n
remove os.remove(filename)\nDeletes the file or directory with the given name. Directories must be\nempty to be removed. If this function fails, it returns nil, plus a string\ndescribing the error.\n
rename os.rename(oldname, newname)\nRenames file or directory named `oldname` to `newname`. If this function\nfails, it returns nil, plus a string describing the error.\n
setlocale os.setlocale(locale [, category])\nSets the current locale of the program. `locale` is a string specifying a\nlocale; `category` is an optional string describing which category to change:\n`"all"`, `"collate"`, `"ctype"`, `"monetary"`, `"numeric"`, or `"time"`; the\ndefault category is `"all"`. The function returns the name of the new locale,\nor nil if the request cannot be honored. If `locale` is the empty string,\nthe current locale is set to an implementation-defined native locale. If\n`locale` is the string "`C`", the current locale is set to the standard\nC locale. When called with nil as the first argument, this function only\nreturns the name of the current locale for the given category.\n
time os.time([table])\nReturns the current time when called without arguments, or a time representing\nthe date and time specified by the given table. This table must have fields\n`year`, `month`, and `day`, and may have fields `hour`, `min`, `sec`, and\n`isdst` (for a description of these fields, see the `os.date` function). The\nreturned value is a number, whose meaning depends on your system. In POSIX,\nWindows, and some other systems, this number counts the number of seconds\nsince some given start time (the "epoch"). In other systems, the meaning\nis not specified, and the number returned by `time` can be used only as an\nargument to `date` and `difftime`.\n
tmpname os.tmpname()\nReturns a string with a file name that can be used for a temporary file. The\nfile must be explicitly opened before its use and explicitly removed when\nno longer needed. On some systems (POSIX), this function also creates a file\nwith that name, to avoid security risks. (Someone else might create the file\nwith wrong permissions in the time between getting the name and creating\nthe file.) You still have to open the file to use it and to remove it (even\nif you do not use it). When possible, you may prefer to use `io.tmpfile`,\nwhich automatically removes the file when the program ends.\n
loadlib package.loadlib(libname, funcname)\nDynamically links the host program with the C library `libname`. Inside this\nlibrary, looks for a function `funcname` and returns this function as a C\nfunction. (So, `funcname` must follow the protocol (see `lua_CFunction`)). This\nis a low-level function. It completely bypasses the package and module\nsystem. Unlike `require`, it does not perform any path searching and does\nnot automatically adds extensions. `libname` must be the complete file name\nof the C library, including if necessary a path and extension. `funcname`\nmust be the exact name exported by the C library (which may depend on the C\ncompiler and linker used). This function is not supported by ANSI C. As such,\nit is only available on some platforms (Windows, Linux, Mac OS X, Solaris,\nBSD, plus other Unix systems that support the `dlfcn` standard).\n
seeall package.seeall(module)\nSets a metatable for `module` with its `__index` field referring to the\nglobal environment, so that this module inherits values from the global\nenvironment. To be used as an option to function `module`.\n
cpath package.cpath\nThe path used by `require` to search for a C loader. Lua initializes the C path\n`package.cpath` in the same way it initializes the Lua path `package.path`,\nusing the environment variable `LUA_CPATH` or a default path defined in\n`luaconf.h`.\n
loaded package.loaded\nA table used by `require` to control which modules are already loaded. When\nyou require a module `modname` and `package.loaded[modname]` is not false,\n`require` simply returns the value stored there.\n
loaders package.loaders\nA table used by `require` to control how to load modules. Each entry in\nthis table is a *searcher function*. When looking for a module, `require`\ncalls each of these searchers in ascending order, with the module name\n(the argument given to `require`) as its sole parameter. The function can\nreturn another function (the module *loader*) or a string explaining why it\ndid not find that module (or nil if it has nothing to say). Lua initializes\nthis table with four functions. The first searcher simply looks for a loader\nin the `package.preload` table. The second searcher looks for a loader as a\nLua library, using the path stored at `package.path`. A path is a sequence\nof *templates* separated by semicolons. For each template, the searcher will\nchange each interrogation mark in the template by `filename`, which is the\nmodule name with each dot replaced by a "directory separator" (such as "`/`"\nin Unix); then it will try to open the resulting file name. So, for instance,\nif the Lua path is the string\n  "./?.lua;./?.lc;/usr/local/?/init.lua"\nthe search for a Lua file for module `foo` will try to open the files\n`./foo.lua`, `./foo.lc`, and `/usr/local/foo/init.lua`, in that order. The\nthird searcher looks for a loader as a C library, using the path given by\nthe variable `package.cpath`. For instance, if the C path is the string\n  "./?.so;./?.dll;/usr/local/?/init.so"\nthe searcher for module `foo` will try to open the files `./foo.so`,\n`./foo.dll`, and `/usr/local/foo/init.so`, in that order. Once it finds\na C library, this searcher first uses a dynamic link facility to link the\napplication with the library. Then it tries to find a C function inside the\nlibrary to be used as the loader. The name of this C function is the string\n"`luaopen_`" concatenated with a copy of the module name where each dot is\nreplaced by an underscore. Moreover, if the module name has a hyphen, its\nprefix up to (and including) the first hyphen is removed. For instance, if the\nmodule name is `a.v1-b.c`, the function name will be `luaopen_b_c`. The fourth\nsearcher tries an *all-in-one loader*. It searches the C path for a library\nfor the root name of the given module. For instance, when requiring `a.b.c`,\nit will search for a C library for `a`. If found, it looks into it for an open\nfunction for the submodule; in our example, that would be `luaopen_a_b_c`. With\nthis facility, a package can pack several C submodules into one single library,\nwith each submodule keeping its original open function.\n
path package.path\nThe path used by `require` to search for a Lua loader. At start-up,\nLua initializes this variable with the value of the environment variable\n`LUA_PATH` or with a default path defined in `luaconf.h`, if the environment\nvariable is not defined. Any "`;;`" in the value of the environment variable\nis replaced by the default path.\n
preload package.preload\nA table to store loaders for specific modules (see `require`).\n
concat table.concat(table [, sep [, i [, j]]])\nGiven an array where all elements are strings or numbers, returns\n`table[i]..sep..table[i+1] ··· sep..table[j]`. The default value for `sep`\nis the empty string, the default for `i` is 1, and the default for `j` is\nthe length of the table. If `i` is greater than `j`, returns the empty string.\n
insert table.insert(table, [pos, ] value)\nInserts element `value` at position `pos` in `table`, shifting up other\nelements to open space, if necessary. The default value for `pos` is\n`n+1`, where `n` is the length of the table (see §2.5.5), so that a call\n`table.insert(t,x)` inserts `x` at the end of table `t`.\n
maxn table.maxn(table)\nReturns the largest positive numerical index of the given table, or zero if\nthe table has no positive numerical indices. (To do its job this function\ndoes a linear traversal of the whole table.)\n
remove table.remove(table [, pos])\nRemoves from `table` the element at position `pos`, shifting down other\nelements to close the space, if necessary. Returns the value of the removed\nelement. The default value for `pos` is `n`, where `n` is the length of the\ntable, so that a call `table.remove(t)` removes the last element of table `t`.\n
sort table.sort(table [, comp])\nSorts table elements in a given order, *in-place*, from `table[1]` to\n`table[n]`, where `n` is the length of the table. If `comp` is given, then it\nmust be a function that receives two table elements, and returns true when\nthe first is less than the second (so that `not comp(a[i+1],a[i])` will be\ntrue after the sort). If `comp` is not given, then the standard Lua operator\n``io.lines`, this function does not close the file when the loop ends.)\n