lua_Alloc (*lua_Alloc)(void *ud, void *ptr, size_t osize, size_t nsize) [void*]\nThe type of the memory-allocation function used by Lua states.  The allocator\nfunction must provide a functionality similar to `realloc`, but not exactly\nthe same.  Its arguments are `ud`, an opaque pointer passed to `lua_newstate`;\n`ptr`, a pointer to the block being allocated/reallocated/freed; `osize`,\nthe original size of the block; `nsize`, the new size of the block.\n`ptr` is `NULL` if and only if `osize` is zero.  When `nsize` is zero,\nthe allocator must return `NULL`; if `osize` is not zero, it should free\nthe block pointed to by `ptr`.  When `nsize` is not zero, the allocator\nreturns `NULL` if and only if it cannot fill the request.  When `nsize`\nis not zero and `osize` is zero, the allocator should behave like `malloc`.\nWhen `nsize` and `osize` are not zero, the allocator behaves like `realloc`.\nLua assumes that the allocator never fails when `osize >= nsize`.\n\nHere is a simple implementation for the allocator function.  It is used in\nthe auxiliary library by `luaL_newstate`.\n\n  static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {\n    (void)ud;  (void)osize;  /* not used */\n    if (nsize == 0) {\n      free(ptr);\n      return NULL;\n    }\n    else\n      return realloc(ptr, nsize);\n  }\n\nThis code assumes that `free(NULL)` has no effect and that `realloc(NULL,\nsize)` is equivalent to `malloc(size)`.  ANSI C ensures both behaviors.\n
lua_atpanic lua_atpanic(lua_State *L, lua_CFunction panicf) [lua_CFunction]\nSets a new panic function and returns the old one.\nIf an error happens outside any protected environment, Lua calls a _panic\nfunction_ and then calls `exit(EXIT_FAILURE)`, thus exiting the host\napplication.  Your panic function can avoid this exit by never returning\n(e.g., doing a long jump).\nThe panic function can access the error message at the top of the stack.\n
lua_call lua_call(lua_State *L, int nargs, int nresults) [void]\nCalls a function.\n\nTo call a function you must use the following protocol: first, the function\nto be called is pushed onto the stack; then, the arguments to the function\nare pushed in direct order; that is, the first argument is pushed first.\nFinally you call `lua_call`; `nargs` is the number of arguments that you\npushed onto the stack.  All arguments and the function value are popped from\nthe stack when the function is called.  The function results are pushed onto\nthe stack when the function returns.  The number of results is adjusted to\n`nresults`, unless `nresults` is `LUA_MULTRET`.  In this case, _all_\nresults from the function are pushed.  Lua takes care that the returned\nvalues fit into the stack space.  The function results are pushed onto the\nstack in direct order (the first result is pushed first), so that after the\ncall the last result is on the top of the stack.\n\nAny error inside the called function is propagated upwards (with a `longjmp`).\n\nThe following example shows how the host program can do the equivalent to\nthis Lua code:\n\n  a = f("how", t.x, 14)\n\nHere it is in C:\n\n  lua_getfield(L, LUA_GLOBALSINDEX, "f"); /* function to be called */\n  lua_pushstring(L, "how");                        /* 1st argument */\n  lua_getfield(L, LUA_GLOBALSINDEX, "t");   /* table to be indexed */\n  lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */\n  lua_remove(L, -2);                  /* remove 't' from the stack */\n  lua_pushinteger(L, 14);                          /* 3rd argument */\n  lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */\n  lua_setfield(L, LUA_GLOBALSINDEX, "a");        /* set global 'a' */\n\nNote that the code above is "balanced": at its end, the stack is back to\nits original configuration.  This is considered good programming practice.\n
lua_CFunction (*lua_CFunction)(lua_State *L) [int]\nType for C functions.\n\nIn order to communicate properly with Lua, a C function must use the\nfollowing protocol, which defines the way parameters and results are passed:\na C function receives its arguments from Lua in its stack in direct order\n(the first argument is pushed first).  So, when the function starts,\n`lua_gettop(L)` returns the number of arguments received by the function.\nThe first argument (if any) is at index 1 and its last argument is at index\n`lua_gettop(L)`.  To return values to Lua, a C function just pushes them onto\nthe stack, in direct order (the first result is pushed first), and returns\nthe number of results.  Any other value in the stack below the results will\nbe properly discarded by Lua.  Like a Lua function, a C function called by\nLua can also return many results.\n\nAs an example, the following function receives a variable number of numerical\narguments and returns their average and sum:\n\n  static int foo (lua_State *L) {\n    int n = lua_gettop(L);    /* number of arguments */\n    lua_Number sum = 0;\n    int i;\n    for (i = 1; i <= n; i++) {\n      if (!lua_isnumber(L, i)) {\n        lua_pushstring(L, "incorrect argument");\n        lua_error(L);\n      }\n      sum += lua_tonumber(L, i);\n    }\n    lua_pushnumber(L, sum/n);        /* first result */\n    lua_pushnumber(L, sum);         /* second result */\n    return 2;                   /* number of results */\n  }\n
lua_checkstack lua_checkstack(lua_State *L, int extra) [int]\nEnsures that there are at least `extra` free stack slots in the stack.\nIt returns false if it cannot grow the stack to that size.  This function\nnever shrinks the stack; if the stack is already larger than the new size,\nit is left unchanged.\n
lua_close lua_close(lua_State *L) [void]\nDestroys all objects in the given Lua state (calling the corresponding\ngarbage-collection metamethods, if any) and frees all dynamic memory used by\nthis state.  On several platforms, you may not need to call this function,\nbecause all resources are naturally released when the host program ends.\nOn the other hand, long-running programs, such as a daemon or a web server,\nmight need to release states as soon as they are not needed, to avoid growing\ntoo large.\n
lua_concat lua_concat(lua_State *L, int n) [void]\nConcatenates the `n` values at the top of the stack, pops them, and leaves\nthe result at the top.  If `n` is 1, the result is the single value on the\nstack (that is, the function does nothing); if `n` is 0, the result is the\nempty string.  Concatenation is performed following the usual semantics of\nLua (see ยง2.5.4).\n
lua_cpcall lua_cpcall(lua_State *L, lua_CFunction func, void *ud) [int]\nCalls the C function `func` in protected mode.  `func` starts with only one\nelement in its stack, a light userdata containing `ud`.  In case of errors,\n`lua_cpcall` returns the same error codes as `lua_pcall`, plus the error\nobject on the top of the stack; otherwise, it returns zero, and does not\nchange the stack.  All values returned by `func` are discarded.\n
lua_createtable lua_createtable(lua_State *L, int narr, int nrec) [void]\nCreates a new empty table and pushes it onto the stack.  The new table has\nspace pre-allocated for `narr` array elements and `nrec` non-array elements.\nThis pre-allocation is useful when you know exactly how many elements the\ntable will have.  Otherwise you can use the function `lua_newtable`.\n
lua_dump lua_dump(lua_State *L, lua_Writer writer, void *data) [int]\nDumps a function as a binary chunk.  Receives a Lua function on the top of\nthe stack and produces a binary chunk that, if loaded again, results in a\nfunction equivalent to the one dumped.  As it produces parts of the chunk,\n`lua_dump` calls function `writer` (see `lua_Writer`) with the given `data`\nto write them.\n\nThe value returned is the error code returned by the last call to the writer;\n0 means no errors.\n\nThis function does not pop the Lua function from the stack.\n
lua_equal lua_equal(lua_State *L, int index1, int index2) [int]\nReturns 1 if the two values in acceptable indices `index1` and `index2`\nare equal, following the semantics of the Lua `==` operator (that is,\nmay call metamethods).  Otherwise returns 0.  Also returns 0 if any of the\nindices is non valid.\n
lua_error lua_error(lua_State *L) [int]\nGenerates a Lua error.  The error message (which can actually be a Lua value\nof any type) must be on the stack top.  This function does a long jump,\nand therefore never returns.  (see `luaL_error`).\n
lua_gc lua_gc(lua_State *L, int what, int data) [int]\nControls the garbage collector.\n\nThis function performs several tasks, according to the value of the parameter\n`what`:\n  * LUA_GCSTOP: stops the garbage collector.\n  * LUA_GCRESTART: restarts the garbage collector.\n  * LUA_GCCOLLECT: performs a full garbage-collection cycle.\n  * LUA_GCCOUNT: returns the current amount of memory (in Kbytes) in use by Lua.\n  * LUA_GCCOUNTB: returns the remainder of dividing the current amount of bytes \n    of memory in use by Lua by 1024.\n  * LUA_GCSTEP: performs an incremental step of garbage collection.\n    The step "size" is controlled by `data` (larger values mean more steps)\n    in a non-specified way.  If you want to control the step size you must\n    experimentally tune the value of `data`.  The function returns 1 if the\n    step finished a garbage-collection cycle.\n  * LUA_GCSETPAUSE: sets `data` as the new value for the _pause_ of the \n    collector (see ยง2.10).  The function returns the previous value of the \n    pause.\n  * LUA_GCSETSTEPMUL: sets `data` as the new value for the _step multiplier_ of\n    the collector (see ยง2.10). The function returns the previous value of the \n    step multiplier.\n
lua_getallocf lua_getallocf(lua_State *L, void **ud) [lua_Alloc]\nReturns the memory-allocation function of a given state.  If `ud` is not\n`NULL`, Lua stores in `*ud` the opaque pointer passed to `lua_newstate`.\n
lua_getfenv lua_getfenv(lua_State *L, int index) [void]\nPushes onto the stack the environment table of the value at the given index.\n
lua_getfield lua_getfield(lua_State *L, int index, const char *k) [void]\nPushes onto the stack the value `t[k]`, where `t` is the value at the given\nvalid index.  As in Lua, this function may trigger a metamethod for the\n"index" event (see ยง2.8).\n
lua_getglobal lua_getglobal(lua_State *L, const char *name) [void]\n\nPushes onto the stack the value of the global `name`.  It is defined as\na macro:\n\n  #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)\n
lua_getmetatable lua_getmetatable(lua_State *L, int index) [int]\nPushes onto the stack the metatable of the value at the given acceptable index.\nIf the index is not valid, or if the value does not have a metatable, the\nfunction returns 0 and pushes nothing on the stack.\n
lua_gettable lua_gettable(lua_State *L, int index) [void]\nPushes onto the stack the value `t[k]`, where `t` is the value at the given\nvalid index and `k` is the value at the top of the stack.\n\nThis function pops the key from the stack (putting the resulting value\nin its place).  As in Lua, this function may trigger a metamethod for the\n"index" event (see ยง2.8).\n
lua_gettop lua_gettop(lua_State *L) [int]\nReturns the index of the top element in the stack.  Because indices start\nat 1, this result is equal to the number of elements in the stack (and so\n0 means an empty stack).\n
lua_insert lua_insert(lua_State *L, int index) [void]\nMoves the top element into the given valid index, shifting up the elements\nabove this index to open space.  Cannot be called with a pseudo-index,\nbecause a pseudo-index is not an actual stack position.\n
lua_Integer lua_Integer [ptrdiff_t]\nThe type used by the Lua API to represent integral values.\n\nBy default it is a `ptrdiff_t`, which is usually the largest signed integral\ntype the machine handles "comfortably".\n
lua_isboolean lua_isboolean(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index has type boolean,\nand 0 otherwise.\n
lua_iscfunction lua_iscfunction(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a C function,\nand 0 otherwise.\n
lua_isfunction lua_isfunction(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a function (either\nC or Lua), and 0 otherwise.\n
lua_islightuserdata lua_islightuserdata(lua_State *L, int index) [int]\n\nReturns 1 if the value at the given acceptable index is a light userdata,\nand 0 otherwise.\n
lua_isnil lua_isnil(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is nil, and 0 otherwise.\n
lua_isnone lua_isnone(lua_State *L, int index) [int]\nReturns 1 if the given acceptable index is not valid (that is, it refers to\nan element outside the current stack), and 0 otherwise.\n
lua_isnoneornil lua_isnoneornil(lua_State *L, int index) [int]\nReturns 1 if the given acceptable index is not valid (that is, it refers to\nan element outside the current stack) or if the value at this index is nil,\nand 0 otherwise.\n
lua_isnumber lua_isnumber(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a number or a string\nconvertible to a number, and 0 otherwise.\n
lua_isstring lua_isstring (lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a string or a number\n(which is always convertible to a string), and 0 otherwise.\n
lua_istable lua_istable(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a table, and 0\notherwise.\n
lua_isthread lua_isthread(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a thread, and\n0 otherwise.\n
lua_isuserdata lua_isuserdata(lua_State *L, int index) [int]\nReturns 1 if the value at the given acceptable index is a userdata (either\nfull or light), and 0 otherwise.\n
lua_lessthan lua_lessthan(lua_State *L, int index1, int index2) [int]\nReturns 1 if the value at acceptable index `index1` is smaller than the\nvalue at acceptable index `index2`, following the semantics of the Lua `<`\noperator (that is, may call metamethods).  Otherwise returns 0.  Also returns\n0 if any of the indices is non valid.\n
lua_load lua_load(lua_State *L, lua_Reader reader, void *data, const char *chunkname) [int]\nLoads a Lua chunk.  If there are no errors, `lua_load` pushes the compiled\nchunk as a Lua function on top of the stack.  Otherwise, it pushes an error\nmessage.  The return values of `lua_load` are:\n  * 0: no errors;\n  * LUA_ERRSYNTAX: syntax error during pre-compilation;\n  * LUA_ERRMEM: memory allocation error.\nThis function only loads a chunk; it does not run it.\n\n`lua_load` automatically detects whether the chunk is text or binary, and\nloads it accordingly (see program `luac`).\n\nThe `lua_load` function uses a user-supplied `reader` function to read the\nchunk (see `lua_Reader`).  The `data` argument is an opaque value passed to\nthe reader function.\n\nThe `chunkname` argument gives a name to the chunk, which is used for error\nmessages and in debug information (see ยง3.8).\n
lua_newstate lua_newstate(lua_Alloc f, void *ud) [lua_State*]\nCreates a new, independent state.  Returns `NULL` if cannot create the state\n(due to lack of memory).  The argument `f` is the allocator function; Lua\ndoes all memory allocation for this state through this function.  The second\nargument, `ud`, is an opaque pointer that Lua simply passes to the allocator\nin every call.\n
lua_newtable lua_newtable(lua_State *L) [void]\nCreates a new empty table and pushes it onto the stack.  It is equivalent to\n`lua_createtable(L, 0, 0)`.\n
lua_newthread lua_newthread(lua_State *L) [lua_State*]\nCreates a new thread, pushes it on the stack, and returns a pointer to a\n`lua_State` that represents this new thread.  The new state returned by this\nfunction shares with the original state all global objects (such as tables),\nbut has an independent execution stack.\n\nThere is no explicit function to close or to destroy a thread.  Threads are\nsubject to garbage collection, like any Lua object.\n
lua_newuserdata lua_newuserdata(lua_State *L, size_t size) [void*]\nThis function allocates a new block of memory with the given size, pushes onto\nthe stack a new full userdata with the block address, and returns this address.\n\nUserdata represent C values in Lua.  A _full userdata_ represents a block\nof memory.  It is an object (like a table): you must create it, it can have\nits own metatable, and you can detect when it is being collected.  A full\nuserdata is only equal to itself (under raw equality).\n\nWhen Lua collects a full userdata with a `gc` metamethod, Lua calls the\nmetamethod and marks the userdata as finalized.  When this userdata is\ncollected again then Lua frees its corresponding memory.\n
lua_next lua_next(lua_State *L, int index) [int]\n\nPops a key from the stack, and pushes a key-value pair from the table at\nthe given index (the "next" pair after the given key).  If there are no more\nelements in the table, then `lua_next` returns 0 (and pushes nothing).\n\nA typical traversal looks like this:\n\n  /* table is in the stack at index 't' */\n  lua_pushnil(L);  /* first key */\n  while (lua_next(L, t) != 0) {\n    /* uses 'key' (at index -2) and 'value' (at index -1) */\n    printf("%s - %s\n",\n           lua_typename(L, lua_type(L, -2)),\n           lua_typename(L, lua_type(L, -1)));\n    /* removes 'value'; keeps 'key' for next iteration */\n    lua_pop(L, 1);\n  }\n\nWhile traversing a table, do not call `lua_tolstring` directly on a key, unless\nyou know that the key is actually a string.  Recall that `lua_tolstring`\n_changes_ the value at the given index; this confuses the next call to\n`lua_next`.\n
lua_Number lua_Number [double]\nThe type of numbers in Lua.  By default, it is double, but that can be\nchanged in `luaconf.h`.\n\nThrough the configuration file you can change Lua to operate with another\ntype for numbers (e.g., float or long).\n
lua_objlen lua_objlen(lua_State *L, int index) [size_t]\nReturns the "length" of the value at the given acceptable index: for strings,\nthis is the string length; for tables, this is the result of the length\noperator ('#'); for userdata, this is the size of the block of memory allocated \nfor the userdata; for other values, it is 0.\n
lua_pcall lua_pcall(lua_State *L, int nargs, int nresults, int errfunc) [int]\nCalls a function in protected mode.\n\nBoth `nargs` and `nresults` have the same meaning as in `lua_call`.  If there\nare no errors during the call, `lua_pcall` behaves exactly like `lua_call`.\nHowever, if there is any error,\n\n`lua_pcall` catches it, pushes a single value on the stack (the error message),\nand returns an error code.  Like `lua_call`, `lua_pcall` always removes the\nfunction and its arguments from the stack.\n\nIf `errfunc` is 0, then the error message returned on the stack is exactly\nthe original error message.  Otherwise, `errfunc` is the stack index of an\n_error handler function_.  (In the current implementation, this index cannot\nbe a pseudo-index.)  In case of runtime errors, this function will be called\nwith the error message and its return value will be the message returned on\nthe stack by `lua_pcall`.\n\nTypically, the error handler function is used to add more debug information\nto the error message, such as a stack traceback.  Such information cannot be\ngathered after the return of `lua_pcall`, since by then the stack has unwound.\n\nThe `lua_pcall` function returns 0 in case of success or one of the following\nerror codes (defined in `lua.h`):\n  * LUA_ERRRUN: a runtime error.\n  * LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the \n    error handler function.\n  * LUA_ERRERR: error while running the error handler function.\n\n  \nlua_pop lua_pop(lua_State *L, int n) [void]\nPops `n` elements from the stack.\n
lua_pushboolean lua_pushboolean(lua_State *L, int b) [void]\nPushes a boolean value with value `b` onto the stack.\n
lua_pushcclosure lua_pushcclosure(lua_State *L, lua_CFunction fn, int n) [void]\nPushes a new C closure onto the stack.\n\nWhen a C function is created, it is possible to associate some values with it,\nthus creating a C closure (see ยง3.4); these values are then accessible to\nthe function whenever it is called.  To associate values with a C function,\nfirst these values should be pushed onto the stack (when there are multiple\nvalues, the first value is pushed first).  Then `lua_pushcclosure` is called to\ncreate and push the C function onto the stack, with the argument `n` telling\nhow many values should be associated with the function.  `lua_pushcclosure`\nalso pops these values from the stack.\n\nThe maximum value for `n` is 255.\n
lua_pushcfunction lua_pushcfunction(lua_State *L, lua_CFunction f) [void]\nPushes a C function onto the stack.  This function receives a pointer to a\nC function and pushes onto the stack a Lua value of type `function` that,\nwhen called, invokes the corresponding C function.\n\nAny function to be registered in Lua must follow the correct protocol to\nreceive its parameters and return its results (see `lua_CFunction`).\n\n`lua_pushcfunction` is defined as a macro:\n\n  #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)\n
lua_pushfstring lua_pushfstring(lua_State *L, const char *fmt, ...) [const char*]\n\nPushes onto the stack a formatted string and returns a pointer to this string.\nIt is similar to the C function `sprintf`, but has some important differences:\n  * You do not have to allocate space for the result: the result is a\n    Lua string and Lua takes care of memory allocation (and deallocation,\n    through garbage collection).\n  * The conversion specifiers are quite restricted.  There are no flags,\n    widths, or precisions.  The conversion specifiers can only be '%%'\n    (inserts a '%' in the string), '%s' (inserts a zero-terminated string,\n    with no size restrictions), '%f' (inserts a `lua_Number`), '%p' (inserts\n    a pointer as a hexadecimal numeral), '%d' (inserts an `int`), and '%c'\n    (inserts an `int` as a character).\n
lua_pushinteger lua_pushinteger(lua_State *L, lua_Integer n) [void]\nPushes a number with value `n` onto the stack.\n
lua_pushlightuserdata lua_pushlightuserdata(lua_State *L, void *p) [void]\nPushes a light userdata onto the stack.\n\nUserdata represent C values in Lua.  A _light userdata_ represents a pointer.\nIt is a value (like a number): you do not create it, it has no individual\nmetatable, and it is not collected (as it was never created).  A light\nuserdata is equal to "any" light userdata with the same C address.\n
lua_pushliteral lua_pushliteral(lua_State *L, const char *s) [void]\nThis macro is equivalent to `lua_pushlstring`, but can be used only when `s` is\na literal string.  In these cases, it automatically provides the string length.\n
lua_pushlstring lua_pushlstring(lua_State *L, const char *s, size_t len) [void]\nPushes the string pointed to by `s` with size `len` onto the stack.  Lua makes\n(or reuses) an internal copy of the given string, so the memory at `s` can\nbe freed or reused immediately after the function returns.  The string can\ncontain embedded zeros.\n
lua_pushnil lua_pushnil(lua_State *L) [void]\nPushes a nil value onto the stack.\n
lua_pushnumber lua_pushnumber(lua_State *L, lua_Number n) [void]\nPushes a number with value `n` onto the stack.\n
lua_pushstring lua_pushstring(lua_State *L, const char *s) [void]\nPushes the zero-terminated string pointed to by `s` onto the stack.  Lua makes\n(or reuses) an internal copy of the given string, so the memory at `s`\ncan be freed or reused immediately after the function returns.  The string\ncannot contain embedded zeros; it is assumed to end at the first zero.\n
lua_pushthread lua_pushthread(lua_State *L) [int]\nPushes the thread represented by `L` onto the stack.  Returns 1 if this\nthread is the main thread of its state.\n
lua_pushvalue lua_pushvalue(lua_State *L, int index) [void]\nPushes a copy of the element at the given valid index onto the stack.\n
lua_pushvfstring lua_pushvfstring(lua_State *L, const char *fmt, va_list argp) [const char*]\nEquivalent to `lua_pushfstring`, except that it receives a `va_list` instead\nof a variable number of arguments.\n
lua_rawequal lua_rawequal(lua_State *L, int index1, int index2) [int]\nReturns 1 if the two values in acceptable indices `index1` and `index2` are\nprimitively equal (that is, without calling metamethods).  Otherwise returns 0.\nAlso returns 0 if any of the indices are non valid.\n
lua_rawget lua_rawget(lua_State *L, int index) [void]\nSimilar to `lua_gettable`, but does a raw access (i.e., without metamethods).\n
lua_rawgeti lua_rawgeti(lua_State *L, int index, int n) [void]\nPushes onto the stack the value `t[n]`, where `t` is the value at the given\nvalid index.  The access is raw; that is, it does not invoke metamethods.\n
lua_rawset lua_rawset(lua_State *L, int index) [void]\nSimilar to `lua_settable`, but does a raw assignment (i.e., without\nmetamethods).\n
lua_rawseti lua_rawseti(lua_State *L, int index, int n) [void]\nDoes the equivalent of `t[n] = v`, where `t` is the value at the given valid\nindex and `v` is the value at the top of the stack.\n\nThis function pops the value from the stack.  The assignment is raw; that is,\nit does not invoke metamethods.\n
lua_Reader (*lua_Reader)(lua_State *L, void *data, size_t *size) [const char*]\nThe reader function used by `lua_load`.  Every time it needs another piece of\nthe chunk, `lua_load` calls the reader, passing along its `data` parameter.\nThe reader must return a pointer to a block of memory with a new piece of\nthe chunk and set `size` to the block size.  The block must exist until the\nreader function is called again.  To signal the end of the chunk, the reader\nmust return `NULL` or set `size` to zero.  The reader function may return\npieces of any size greater than zero.\n
lua_register lua_register(lua_State *L, const char *name, lua_CFunction f) [void]\nSets the C function `f` as the new value of global `name`.  It is defined\nas a macro:\n\n  #define lua_register(L,n,f) (lua_pushcfunction(L, f), lua_setglobal(L, n))\n
lua_remove lua_remove(lua_State *L, int index) [void]\nRemoves the element at the given valid index, shifting down the elements\nabove this index to fill the gap.  Cannot be called with a pseudo-index,\nbecause a pseudo-index is not an actual stack position.\n
lua_replace lua_replace(lua_State *L, int index) [void]\nMoves the top element into the given position (and pops it), without shifting\nany element (therefore replacing the value at the given position).\n
lua_resume lua_resume(lua_State *L, int narg) [int]\nStarts and resumes a coroutine in a given thread.\n\nTo start a coroutine, you first create a new thread (see `lua_newthread`); then\nyou push onto its stack the main function plus any arguments; then you call\n`lua_resume`, with `narg` being the number of arguments.  This call returns\nwhen the coroutine suspends or finishes its execution.  When it returns, the\nstack contains all values passed to `lua_yield`, or all values returned by\nthe body function.  `lua_resume` returns `LUA_YIELD` if the coroutine yields,\n0 if the coroutine finishes its execution without errors, or an error code\nin case of errors (see `lua_pcall`).  In case of errors, the stack is not\nunwound, so you can use the debug API over it.  The error message is on the\ntop of the stack.  To restart a coroutine, you put on its stack only the\nvalues to be passed as results from `yield`, and then call `lua_resume`.\n
lua_setallocf lua_setallocf(lua_State *L, lua_Alloc f, void *ud) [void]\nChanges the allocator function of a given state to `f` with user data `ud`.\n
lua_setfenv lua_setfenv(lua_State *L, int index) [int]\nPops a table from the stack and sets it as the new environment for the value\nat the given index.  If the value at the given index is neither a function\nnor a thread nor a userdata, `lua_setfenv` returns 0.  Otherwise it returns 1.\n
lua_setfield lua_setfield(lua_State *L, int index, const char *k) [void]\nDoes the equivalent to `t[k] = v`, where `t` is the value at the given valid\nindex and `v` is the value at the top of the stack.\n\nThis function pops the value from the stack.  As in Lua, this function may\ntrigger a metamethod for the "newindex" event (see ยง2.8).\n
lua_setglobal lua_setglobal(lua_State *L, const char *name) [void]\nPops a value from the stack and sets it as the new value of global `name`.\nIt is defined as a macro:\n\n  #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)\n
lua_setmetatable lua_setmetatable(lua_State *L, int index) [int]\nPops a table from the stack and sets it as the new metatable for the value\nat the given acceptable index.\n
lua_settable lua_settable(lua_State *L, int index) [void]\nDoes the equivalent to `t[k] = v`, where `t` is the value at the given\nvalid index,\n\n`v` is the value at the top of the stack, and `k` is the value just below\nthe top.\n\nThis function pops both the key and the value from the stack.  As in Lua,\nthis function may trigger a metamethod for the "newindex" event (see ยง2.8).\n
lua_settop lua_settop(lua_State *L, int index) [void]\nAccepts any acceptable index, or 0, and sets the stack top to this index.\nIf the new top is larger than the old one, then the new elements are filled\nwith <b>nil</b>.  If `index` is 0, then all stack elements are removed.\n
lua_State lua_State [struct lua_State]\nOpaque structure that keeps the whole state of a Lua interpreter.  The Lua\nlibrary is fully reentrant: it has no global variables.  All information\nabout a state is kept in this structure.\n\nA pointer to this state must be passed as the first argument to every\nfunction in the library, except to `lua_newstate`, which creates a Lua state\nfrom scratch.\n
lua_status lua_status(lua_State *L) [int]\nReturns the status of the thread `L`.\n\nThe status can be 0 for a normal thread, an error code if the thread finished\nits execution with an error, or `LUA_YIELD` if the thread is suspended.\n
lua_toboolean lua_toboolean(lua_State *L, int index) [int]\nConverts the Lua value at the given acceptable index to a C boolean value\n(0 or 1).  Like all tests in Lua,\n\n`lua_toboolean` returns 1 for any Lua value different from false and nil;\notherwise it returns 0.  It also returns 0 when called with a non-valid index.\n(If you want to accept only actual boolean values, use `lua_isboolean`\nto test the value's type.)\n
lua_tocfunction lua_tocfunction(lua_State *L, int index) [lua_CFunction]\nConverts a value at the given acceptable index to a C function.  That value\nmust be a C function; otherwise, returns `NULL`.\n
lua_tointeger lua_tointeger(lua_State *L, int index) [lua_Integer]\nConverts the Lua value at the given acceptable index to the signed integral\ntype `lua_Integer`.  The Lua value must be a number or a string convertible\nto a number (see ยง2.2.1); otherwise, `lua_tointeger` returns 0.\n\nIf the number is not an integer, it is truncated in some non-specified way.\n
lua_tolstring lua_tolstring(lua_State *L, int index, size_t *len) [const char*]\nConverts the Lua value at the given acceptable index to a C string.  If `len`\nis not `NULL`, it also sets `*len` with the string length.  The Lua value\nmust be a string or a number; otherwise, the function returns `NULL`.\nIf the value is a number, then `lua_tolstring` also _changes the actual\nvalue in the stack to a string_.  (This change confuses `lua_next` when\n`lua_tolstring` is applied to keys during a table traversal.)\n\n`lua_tolstring` returns a fully aligned pointer to a string inside the\nLua state.  This string always has a zero ('\0') after its last character\n(as in C), but can contain other zeros in its body.  Because Lua has garbage\ncollection, there is no guarantee that the pointer returned by `lua_tolstring`\nwill be valid after the corresponding value is removed from the stack.\n
lua_tonumber lua_tonumber(lua_State *L, int index) [lua_Number]\nConverts the Lua value at the given acceptable index to the C type `lua_Number`\n(see `lua_Number`).  The Lua value must be a number or a string convertible\nto a number (see ยง2.2.1); otherwise, `lua_tonumber` returns 0.\n
lua_topointer lua_topointer(lua_State *L, int index) [const void*]\nConverts the value at the given acceptable index to a generic C pointer\n(`void*`).  The value can be a userdata, a table, a thread, or a function;\notherwise, `lua_topointer` returns `NULL`.  Different objects will give\ndifferent pointers.  There is no way to convert the pointer back to its\noriginal value.\n\nTypically this function is used only for debug information.\n
lua_tostring lua_tostring(lua_State *L, int index) [const char*]\nEquivalent to `lua_tolstring` with `len` equal to `NULL`.\n
lua_tothread lua_tothread(lua_State *L, int index) [lua_State*]\nConverts the value at the given acceptable index to a Lua thread (represented\nas `lua_State*`).  This value must be a thread; otherwise, the function\nreturns `NULL`.\n
lua_touserdata lua_touserdata(lua_State *L, int index) [void*]\nIf the value at the given acceptable index is a full userdata, returns\nits block address.  If the value is a light userdata, returns its pointer.\nOtherwise, returns `NULL`.\n
lua_type lua_type(lua_State *L, int index) [int]\nReturns the type of the value in the given acceptable index, or `LUA_TNONE` for\na non-valid index (that is, an index to an "empty" stack position).  The types\nreturned by `lua_type` are coded by the following constants defined in `lua.h`:\n`LUA_TNIL`, `LUA_TNUMBER`, `LUA_TBOOLEAN`, `LUA_TSTRING`, `LUA_TTABLE`,\n`LUA_TFUNCTION`, `LUA_TUSERDATA`, `LUA_TTHREAD`, and `LUA_TLIGHTUSERDATA`.\n
lua_typename lua_typename(lua_State *L, int tp) [const char*]\nReturns the name of the type encoded by the value `tp`, which must be one\nthe values returned by `lua_type`.\n
lua_Writer (*lua_Writer)(lua_State *L, const void* p, size_t sz, void* ud) [int]\nThe type of the writer function used by `lua_dump`.  Every time it produces\nanother piece of chunk, `lua_dump` calls the writer, passing along the buffer\nto be written (`p`), its size (`sz`), and the `data` parameter supplied to\n`lua_dump`.\n\nThe writer returns an error code: 0 means no errors; any other value means\nan error and stops `lua_dump` from calling the writer again.\n
lua_xmove lua_xmove(lua_State *from, lua_State *to, int n) [void]\nExchange values between different threads of the _same_ global state.\n\nThis function pops `n` values from the stack `from`, and pushes them onto\nthe stack `to`.\n
lua_yield lua_yield(lua_State *L, int nresults) [int]\nYields a coroutine.\n\nThis function should only be called as the return expression of a C function,\nas follows:\n\n  return lua_yield (L, nresults);\n\nWhen a C function calls `lua_yield` in that way, the running coroutine\nsuspends its execution, and the call to `lua_resume` that started this\ncoroutine returns.  The parameter `nresults` is the number of values from\nthe stack that are passed as results to `lua_resume`.\n
lua_Debug lua_Debug [struct]\ntypedef struct lua_Debug {\n  int event;\n  const char *name;           /* (n) */\n  const char *namewhat;       /* (n) */\n  const char *what;           /* (S) */\n  const char *source;         /* (S) */\n  int currentline;            /* (l) */\n  int nups;                   /* (u) number of upvalues */\n  int linedefined;            /* (S) */\n  int lastlinedefined;        /* (S) */\n  char short_src[LUA_IDSIZE]; /* (S) */\n  /* private part */\n  _other fields_\n} lua_Debug;\n\nA structure used to carry different pieces of information about an active\nfunction.  `lua_getstack` fills only the private part of this structure, for\nlater use.  To fill the other fields of `lua_Debug` with useful information,\ncall `lua_getinfo`.\n\nThe fields of `lua_Debug` have the following meaning:\n  * source: If the function was defined in a string, then `source` is that \n    string. If the function was defined in a file, then `source` starts with a\n    '@' followed by the file name.\n  * short_src: a "printable" version of `source`, to be used in error messages.\n  * linedefined: the line number where the definition of the function starts.\n  * lastlinedefined: the line number where the definition of the function ends.\n  * what: the string "Lua" if the function is a Lua function, "C" if it is a\n    C function, "main" if it is the main part of a chunk, and "tail" if it was\n    a function that did a tail call.  In the latter case, Lua has no other\n    information about the function.\n  * currentline: the current line where the given function is executing.\n    When no line information is available, `currentline` is set to -1.\n  * name: a reasonable name for the given function. Because functions in Lua \n    are first-class values, they do not have a fixed name: some functions\n    can be the value of multiple global variables, while others can be\n    stored only in a table field.  The `lua_getinfo` function checks how the\n    function was called to find a suitable name.  If it cannot find a name,\n    then `name` is set to `NULL`.\n  * namewhat: explains the `name` field. The value of `namewhat` can be \n    "global", "local", "method", "field", "upvalue", or "" (the empty string),\n    according to how the function was called.  (Lua uses the empty string\n    when no other option seems to apply.)\n  * nups: the number of upvalues of the function.\n
lua_gethook lua_gethook(lua_State *L) [lua_Hook]\nReturns the current hook function.\n
lua_gethookcount lua_gethookcount(lua_State *L) [int]\nReturns the current hook count.\n
lua_gethookmask lua_gethookmask(lua_State *L) [int]\nReturns the current hook mask.\n
lua_getinfo lua_getinfo(lua_State *L, const char *what, lua_Debug *ar) [int]\nReturns information about a specific function or function invocation.\n\nTo get information about a function invocation, the parameter `ar` must be a\nvalid activation record that was filled by a previous call to `lua_getstack`\nor given as argument to a hook (see `lua_Hook`).\n\nTo get information about a function you push it onto the stack and start the\n`what` string with the character '>'.  (In that case, `lua_getinfo` pops the\nfunction in the top of the stack.)  For instance, to know in which line a\nfunction `f` was defined, you can write the following code:\n\n  lua_Debug ar;\n  lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* get global 'f' */\n  lua_getinfo(L, ">S", &ar);\n  printf("%d\n", ar.linedefined);\n\nEach character in the string `what` selects some fields of the structure\n`ar` to be filled or a value to be pushed on the stack:\n  * 'n': fills in the field `name` and `namewhat`;\n  * 'S': fills in the fields `source`, `short_src`, `linedefined`, \n    `lastlinedefined`, and `what`;\n  * 'l': fills in the field `currentline`;\n  * 'u': fills in the field `nups`;\n  * 'f': pushes onto the stack the function that is running at the given level;\n  * 'L': pushes onto the stack a table whose indices are the numbers of the \n    lines that are valid on the function.  (A _valid line_ is a line with\n    some associated code, that is, a line where you can put a break point.\n    Non-valid lines include empty lines and comments.)\n\nThis function returns 0 on error (for instance, an invalid option in `what`).\n
lua_getlocal lua_getlocal(lua_State *L, lua_Debug *ar, int n) [const char*]\nGets information about a local variable of a given activation record.\nThe parameter `ar` must be a valid activation record that was filled\nby a previous call to `lua_getstack` or given as argument to a hook (see\n`lua_Hook`).  The index `n` selects which local variable to inspect (1 is the\nfirst parameter or active local variable, and so on, until the last active\nlocal variable).  `lua_getlocal` pushes the variable's value onto the stack\nand returns its name.\n\nVariable names starting with '(' (open parentheses) represent internal\nvariables (loop control variables, temporaries, and C function locals).\n\nReturns `NULL` (and pushes nothing) when the index is greater than the number\nof active local variables.\n
lua_getstack lua_getstack(lua_State *L, int level, lua_Debug *ar) [int]\nGet information about the interpreter runtime stack.\n\nThis function fills parts of a `lua_Debug` structure with an identification of\nthe _activation record_ of the function executing at a given level.  Level 0\nis the current running function, whereas level _n+1_ is the function that\nhas called level _n_.  When there are no errors, `lua_getstack` returns 1;\nwhen called with a level greater than the stack depth, it returns 0.\n
lua_getupvalue lua_getupvalue(lua_State *L, int funcindex, int n) [const char*]\nGets information about a closure's upvalue.  (For Lua functions, upvalues are\nthe external local variables that the function uses, and that are consequently\nincluded in its closure.)  `lua_getupvalue` gets the index `n` of an upvalue,\npushes the upvalue's value onto the stack, and returns its name.`funcindex`\npoints to the closure in the stack.  (Upvalues have no particular order,\nas they are active through the whole function.  So, they are numbered in an\narbitrary order.)\n\nReturns `NULL` (and pushes nothing) when the index is greater than the\nnumber of upvalues.  For C functions, this function uses the empty string\n"" as a name for all upvalues.\n
lua_Hook (*lua_Hook)(lua_State *L, lua_Debug *ar) [void]\nType for debugging hook functions.\n\nWhenever a hook is called, its `ar` argument has its field `event` set to the\nspecific event that triggered the hook.  Lua identifies these events with\nthe following constants: `LUA_HOOKCALL`, `LUA_HOOKRET`, `LUA_HOOKTAILRET`,\n`LUA_HOOKLINE`, and `LUA_HOOKCOUNT`.  Moreover, for line events, the\nfield `currentline` is also set.  To get the value of any other field in\n`ar`, the hook must call `lua_getinfo`.  For return events, `event` can be\n`LUA_HOOKRET`, the normal value, or `LUA_HOOKTAILRET`.  In the latter case,\nLua is simulating a return from a function that did a tail call; in this case,\nit is useless to call `lua_getinfo`.\n\nWhile Lua is running a hook, it disables other calls to hooks.  Therefore,\nif a hook calls back Lua to execute a function or a chunk, this execution\noccurs without any calls to hooks.\n
lua_sethook lua_sethook(lua_State *L, lua_Hook f, int mask, int count) [int]\nSets the debugging hook function.\n\nArgument `f` is the hook function.\n\n`mask` specifies on which events the hook will be called: it is formed by a\nbitwise or of the constants `LUA_MASKCALL`, `LUA_MASKRET`, `LUA_MASKLINE`,\nand `LUA_MASKCOUNT`.  The `count` argument is only meaningful when the mask\nincludes `LUA_MASKCOUNT`.  For each event, the hook is called as explained\nbelow:\n  * The call hook: is called when the interpreter calls a function. The hook is \n    called just after Lua enters the new function, before the function gets\n    its arguments.\n  * The return hook: is called when the interpreter returns from a function.\n    The hook is called just before Lua leaves the function.  You have no\n    access to the values to be returned by the function.\n  * The line hook: is called when the interpreter is about to start the \n    execution of a new line of code, or when it jumps back in the code (even\n    to the same line).  (This event only happens while Lua is executing a\n    Lua function.)\n  * The count hook: is called after the interpreter executes every `count` \n    instructions.  (This event only happens while Lua is executing a Lua\n    function.)\n\nA hook is disabled by setting `mask` to zero.\n
lua_setlocal lua_setlocal(lua_State *L, lua_Debug *ar, int n) [const char*]\nSets the value of a local variable of a given activation record.  Parameters\n`ar` and `n` are as in `lua_getlocal` (see `lua_getlocal`).  `lua_setlocal`\nassigns the value at the top of the stack to the variable and returns its name.\nIt also pops the value from the stack.\n\nReturns `NULL` (and pops nothing) when the index is greater than the number\nof active local variables.\n
lua_setupvalue lua_setupvalue(lua_State *L, int funcindex, int n) [const char*]\nSets the value of a closure's upvalue.  It assigns the value at the top of\nthe stack to the upvalue and returns its name.  It also pops the value from\nthe stack.  Parameters `funcindex` and `n` are as in the `lua_getupvalue`\n(see `lua_getupvalue`).\n\nReturns `NULL` (and pops nothing) when the index is greater than the number\nof upvalues.\n
luaL_addchar luaL_addchar(luaL_Buffer *B, char c) [void]\nAdds the character `c` to the buffer `B` (see `luaL_Buffer`).\n
luaL_addlstring luaL_addlstring(luaL_Buffer *B, const char *s, size_t l) [void]\nAdds the string pointed to by `s` with length `l` to the buffer `B` (see\n`luaL_Buffer`).  The string may contain embedded zeros.\n
luaL_addsize luaL_addsize(luaL_Buffer *B, size_t n) [void]\nAdds to the buffer `B` (see `luaL_Buffer`) a string of length `n` previously\ncopied to the buffer area (see `luaL_prepbuffer`).\n
luaL_addstring luaL_addstring(luaL_Buffer *B, const char *s) [void]\nAdds the zero-terminated string pointed to by `s` to the buffer `B` (see\n`luaL_Buffer`).  The string may not contain embedded zeros.\n
luaL_addvalue luaL_addvalue(luaL_Buffer *B) [void]\nAdds the value at the top of the stack to the buffer `B` (see `luaL_Buffer`).\nPops the value.\n\nThis is the only function on string buffers that can (and must) be called with\nan extra element on the stack, which is the value to be added to the buffer.\n
luaL_argcheck luaL_argcheck(lua_State *L, int cond, int narg, const char *extramsg) [void]\nChecks whether `cond` is true.  If not, raises an error with the following\nmessage, where `func` is retrieved from the call stack:\n\n  bad argument #<narg> to <func> (<extramsg>)\n
luaL_argerror luaL_argerror(lua_State *L, int narg, const char *extramsg) [int]\nRaises an error with the following message, where `func` is retrieved from\nthe call stack:\n\n  bad argument #<narg> to <func> (<extramsg>)\n\nThis function never returns, but it is an idiom to use it in C functions as\n`return luaL_argerror(args)`.\n
luaL_Buffer luaL_Buffer [struct]\nType for a _string buffer_.\n\nA string buffer allows C code to build Lua strings piecemeal.  Its pattern\nof use is as follows:\n  * First you declare a variable `b` of type `luaL_Buffer`.\n  * Then you initialize it with a call `luaL_buffinit(L, &b)`.\n  * Then you add string pieces to the buffer calling any of the `luaL_add*` \n    functions.\n  * You finish by calling `luaL_pushresult(&b)`. This call leaves the final \n    string on the top of the stack.\nDuring its normal operation, a string buffer uses a variable number of\nstack slots.  So, while using a buffer, you cannot assume that you know\nwhere the top of the stack is.  You can use the stack between successive\ncalls to buffer operations as long as that use is balanced; that is, when you\ncall a buffer operation, the stack is at the same level it was immediately\nafter the previous buffer operation.  (The only exception to this rule is\n`luaL_addvalue`.)  After calling `luaL_pushresult` the stack is back to its\nlevel when the buffer was initialized, plus the final string on its top.\n
luaL_buffinit luaL_buffinit(lua_State *L, luaL_Buffer *B) [void]\nInitializes a buffer `B`.  This function does not allocate any space; the\nbuffer must be declared as a variable (see `luaL_Buffer`).\n
luaL_callmeta luaL_callmeta(lua_State *L, int obj, const char *e) [int]\nCalls a metamethod.\n\nIf the object at index `obj` has a metatable and this metatable has a field\n`e`, this function calls this field and passes the object as its only\nargument.  In this case this function returns 1 and pushes onto the stack\nthe value returned by the call.  If there is no metatable or no metamethod,\nthis function returns 0 (without pushing any value on the stack).\n
luaL_checkany luaL_checkany(lua_State *L, int narg) [void]\nChecks whether the function has an argument of any type (including nil)\nat position `narg`.\n
luaL_checkint luaL_checkint(lua_State *L, int narg) [int]\nChecks whether the function argument `narg` is a number and returns this\nnumber cast to an `int`.\n
luaL_checkinteger luaL_checkinteger(lua_State *L, int narg) [lua_Integer]\nChecks whether the function argument `narg` is a number and returns this\nnumber cast to a `lua_Integer`.\n
luaL_checklong luaL_checklong(lua_State *L, int narg) [long]\nChecks whether the function argument `narg` is a number and returns this\nnumber cast to a `long`.\n
luaL_checklstring luaL_checklstring(lua_State *L, int narg, size_t *l) [const char*]\nChecks whether the function argument `narg` is a string and returns this\nstring; if `l` is not `NULL` fills `*l` with the string's length.\n\nThis function uses `lua_tolstring` to get its result, so all conversions\nand caveats of that function apply here.\n
luaL_checknumber luaL_checknumber(lua_State *L, int narg) [lua_Number]\nChecks whether the function argument `narg` is a number and returns this\nnumber.\n
luaL_checkoption luaL_checkoption(lua_State *L, int narg, const char *def, const char *const lst[]) [int]\nChecks whether the function argument `narg` is a string and searches for this\nstring in the array `lst` (which must be NULL-terminated).  Returns the index\nin the array where the string was found.  Raises an error if the argument\nis not a string or if the string cannot be found.\n\nIf `def` is not `NULL`, the function uses `def` as a default value when\nthere is no argument `narg` or if this argument is nil.\n\nThis is a useful function for mapping strings to C enums.  (The usual\nconvention in Lua libraries is to use strings instead of numbers to select\noptions.)\n
luaL_checkstack luaL_checkstack(lua_State *L, int sz, const char *msg) [void]\nGrows the stack size to `top + sz` elements, raising an error if the stack\ncannot grow to that size.  `msg` is an additional text to go into the error\nmessage.\n
luaL_checkstring luaL_checkstring(lua_State *L, int narg) [const char*]\nChecks whether the function argument `narg` is a string and returns this\nstring.\n\nThis function uses `lua_tolstring` to get its result, so all conversions\nand caveats of that function apply here.\n
luaL_checktype luaL_checktype(lua_State *L, int narg, int t) [void]\nChecks whether the function argument `narg` has type `t`.  See `lua_type`\nfor the encoding of types for `t`.\n
luaL_checkudata luaL_checkudata(lua_State *L, int narg, const char *tname) [void*]\nChecks whether the function argument `narg` is a userdata of the type `tname`\n(see `luaL_newmetatable`).\n
luaL_dofile luaL_dofile(lua_State *L, const char *filename) [int]\nLoads and runs the given file.  It is defined as the following macro:\n\n  (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\nIt returns 0 if there are no errors or 1 in case of errors.\n
luaL_dostring luaL_dostring(lua_State *L, const char *str) [int]\nLoads and runs the given string. It is defined as the following macro:\n\n  (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\nIt returns 0 if there are no errors or 1 in case of errors.\n
luaL_error luaL_error(lua_State *L, const char *fmt, ...) [int]\nRaises an error.  The error message format is given by `fmt` plus any extra\narguments, following the same rules of `lua_pushfstring`.  It also adds at\nthe beginning of the message the file name and the line number where the\nerror occurred, if this information is available.\n\nThis function never returns, but it is an idiom to use it in C functions as\n`return luaL_error(args)`.\n
luaL_getmetafield luaL_getmetafield(lua_State *L, int obj, const char *e) [int]\nPushes onto the stack the field `e` from the metatable of the object at index\n`obj`.  If the object does not have a metatable, or if the metatable does\nnot have this field, returns 0 and pushes nothing.\n
luaL_getmetatable luaL_getmetatable(lua_State *L, const char *tname) [void]\nPushes onto the stack the metatable associated with name `tname` in the\nregistry (see `luaL_newmetatable`).\n
luaL_gsub luaL_gsub(lua_State *L, const char *s, const char *p, const char *r) [const char*]\nCreates a copy of string `s` by replacing any occurrence of the string `p`\nwith the string `r`.  Pushes the resulting string on the stack and returns it.\n
luaL_loadbuffer luaL_loadbuffer(lua_State *L, const char *buff, size_t sz, const char *name) [int] \nLoads a buffer as a Lua chunk.  This function uses `lua_load` to load the\nchunk in the buffer pointed to by `buff` with size `sz`.\n\nThis function returns the same results as `lua_load`.  `name` is the chunk\nname, used for debug information and error messages.\n
luaL_loadfile luaL_loadfile(lua_State *L, const char *filename) [int]\nLoads a file as a Lua chunk.  This function uses `lua_load` to load the chunk\nin the file named `filename`.  If `filename` is `NULL`, then it loads from the\nstandard input.  The first line in the file is ignored if it starts with a `#`.\n\nThis function returns the same results as `lua_load`, but it has an extra\nerror code `LUA_ERRFILE` if it cannot open/read the file.\n\nAs `lua_load`, this function only loads the chunk; it does not run it.\n
luaL_loadstring luaL_loadstring(lua_State *L, const char *s) [int]\nLoads a string as a Lua chunk.  This function uses `lua_load` to load the\nchunk in the zero-terminated string `s`.\n\nThis function returns the same results as `lua_load`.\n\nAlso as `lua_load`, this function only loads the chunk; it does not run it.\n
luaL_newmetatable luaL_newmetatable(lua_State *L, const char *tname) [int]\nIf the registry already has the key `tname`, returns 0.  Otherwise, creates\na new table to be used as a metatable for userdata, adds it to the registry\nwith key `tname`, and returns 1.\n\nIn both cases pushes onto the stack the final value associated with `tname`\nin the registry.\n
luaL_newstate luaL_newstate(void) [lua_State*]\nCreates a new Lua state.  It calls `lua_newstate` with an allocator based\non the standard C `realloc` function and then sets a panic function (see\n`lua_atpanic`) that prints an error message to the standard error output in\ncase of fatal errors.\n\nReturns the new state, or `NULL` if there is a memory allocation error.\n
luaL_openlibs luaL_openlibs(lua_State *L) [void]\nOpens all standard Lua libraries into the given state.\n
luaL_optint luaL_optint(lua_State *L, int narg, int d) [int]\nIf the function argument `narg` is a number, returns this number cast to\nan `int`.  If this argument is absent or is nil, returns `d`.  Otherwise,\nraises an error.\n
luaL_optinteger luaL_optinteger(lua_State *L, int narg, lua_Integer d) [lua_Integer]\nIf the function argument `narg` is a number, returns this number cast to a\n`lua_Integer`.  If this argument is absent or is nil, returns `d`.  Otherwise,\nraises an error.\n
luaL_optlong luaL_optlong(lua_State *L, int narg, long d) [long]\nIf the function argument `narg` is a number, returns this number cast to a\n`long`.  If this argument is absent or is nil, returns `d`.  Otherwise,\nraises an error.\n
luaL_optlstring luaL_optlstring(lua_State *L, int narg, const char *d, size_t *l) [const char*]\nIf the function argument `narg` is a string, returns this string.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n\nIf `l` is not `NULL`, fills the position `*l` with the results's length.\n
luaL_optnumber luaL_optnumber(lua_State *L, int narg, lua_Number d) [lua_Number]\nIf the function argument `narg` is a number, returns this number.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n
luaL_optstring luaL_optstring(lua_State *L, int narg, const char *d) [const char*]\nIf the function argument `narg` is a string, returns this string.  If this\nargument is absent or is nil, returns `d`.  Otherwise, raises an error.\n
luaL_prepbuffer luaL_prepbuffer(luaL_Buffer *B) [char*]\nReturns an address to a space of size `LUAL_BUFFERSIZE` where you can copy\na string to be added to buffer `B` (see `luaL_Buffer`).  After copying the\nstring into this space you must call `luaL_addsize` with the size of the\nstring to actually add it to the buffer.\n
luaL_pushresult luaL_pushresult(luaL_Buffer *B) [void]\nFinishes the use of buffer `B` leaving the final string on the top of\nthe stack.\n
luaL_ref luaL_ref(lua_State *L, int t) [int]\nCreates and returns a _reference_, in the table at index `t`, for the object\nat the top of the stack (and pops the object).\n\nA reference is a unique integer key.  As long as you do not manually add\ninteger keys into table `t`, `luaL_ref` ensures the uniqueness of the key\nit returns.  You can retrieve an object referred by reference `r` by calling\n`lua_rawgeti(L, t, r)`.  Function `luaL_unref` frees a reference and its\nassociated object.\n\nIf the object at the top of the stack is nil, `luaL_ref` returns the constant\n`LUA_REFNIL`.  The constant `LUA_NOREF` is guaranteed to be different from\nany reference returned by `luaL_ref`.\n
luaL_Reg luaL_Reg [struct]\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\nType for arrays of functions to be registered by `luaL_register`.  `name`\nis the function name and `func` is a pointer to the function.  Any array of\n`luaL_Reg` must end with an sentinel entry in which both `name` and `func`\nare `NULL`.\n
luaL_register luaL_register(lua_State *L, const char *libname, const luaL_Reg *l) [void]\nOpens a library.\n\nWhen called with `libname` equal to `NULL`, it simply registers all functions\nin the list `l` (see `luaL_Reg`) into the table on the top of the stack.\n\nWhen called with a non-null `libname`, `luaL_register` creates a new table\n`t`, sets it as the value of the global variable `libname`, sets it as the\nvalue of `package.loaded[libname]`, and registers on it all functions in the\nlist `l`.  If there is a table in `package.loaded[libname]` or in variable\n`libname`, reuses this table instead of creating a new one.\n\nIn any case the function leaves the table on the top of the stack.\n
luaL_typename luaL_typename(lua_State *L, int index) [const char*]\nReturns the name of the type of the value at the given index.\n
luaL_typerror luaL_typerror(lua_State *L, int narg, const char *tname) [int]\nGenerates an error with a message like the following:\n\n  [location]: bad argument [narg] to '[func]' ([tname] expected, got [rt])\n\nwhere [location] is produced by `luaL_where`, [func] is the name of the\ncurrent function, and [rt] is the type name of the actual argument.\n
luaL_unref luaL_unref(lua_State *L, int t, int ref) [void]\nReleases reference `ref` from the table at index `t` (see `luaL_ref`).\nThe entry is removed from the table, so that the referred object can be\ncollected.  The reference `ref` is also freed to be used again.\n\nIf `ref` is `LUA_NOREF` or `LUA_REFNIL`, `luaL_unref` does nothing.\n
luaL_where luaL_where(lua_State *L, int lvl) [void]\nPushes onto the stack a string identifying the current position of the\ncontrol at level `lvl` in the call stack.  Typically this string has the\nfollowing format:\n\n  _chunkname_:_currentline_:\n\nLevel 0 is the running function, level 1 is the function that called the\nrunning function, etc.\n\nThis function is used to build a prefix for error messages.\n
